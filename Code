 /**
 
 /                   _                                          _    /
 /     /\           | |                                        | |   /
 /    /  \     ___  | |_   _ __   ___    _ __     ___   _ __   | |_  /
 /   / /\ \   / __| | __| | '__| / _ \  | '_ \   / _ \ | '_ \  | __| /
 /  / ____ \  \__ \ | |_  | |   | (_) | | | | | |  __/ | | | | | |_  /
 / /_/    \_\ |___/  \__| |_|    \___/  |_| |_|  \___| |_| |_|  \__| /
 
 
 
 //melody:
 //b d f#
 IMPORTANT INFO
 
 Scenes:
 -1 - Ship Calculations
 0 - Gameplay
 1 - Edit Ship
 2 - Edit Part
 3 - Map
 4 - Main Menu
 5 - Pause Menu ()
 6 - Settings ()
 7 - Research Tree
 8 - Planet
 9 - Rewards Screen
 10 - Defeat Screen
 11 - Shop
 12 - Background test
 13 - Error message ()
 14 - (cannot be used with lastscene)
 15 - (cannot be used with lastscene)
 Secondary Scenes:
 0 - None
 1 - Paused
 2 - Settings
 3 - Popup Message
 4 - Loading/Transition
 5 - Load Galaxy
 6 - Tutorial
 7 - Enemy Destroyed Animation(needs to be removed)
 8 - controls menu
 
 
 tutorials:    
 ship designer  
 part designer
 research 
 combat
 planet
 shop
 
 Wyatt TODO:
 improve shop gui
 make graphics for credits counter(simple half trapezoid would look good)
 create map legend
 final boss leg graphics
 
 BOSS PROBLEMS:
 rapid fire boss destroys itself
 damage all parts boss does not damage all parts
 damage all parts boss does not have custom design
 infinite damage boss gives negative credits
 infinite damage boss has super fast particles on hit
 spider drones do not fire
 spider needs a big weapon
 
 
 TODO:
   make maximum overshield amount (5X normal health)
 make universe map
   fix bosses not giving the correct number of credits for winning
   fix ships destroying themselves
   make ship editor have displays for RMB and LMB
     fix all bosses 
 sound
 weight map elements
   final boss graphics
 fix boss drones not firing
 improve pixel tooltips
     improve credits counter and make it show in every place that it is needed
   make explosion effects play when a projectile hits a planet
   add new particle effect for lasers hitting a ship
   improve the look of shops
 (optional)optimize planets
 add a button to swap between different rotations of the same part
 tutorial
 (optional)customizable color schemes
 limit framerate
 (optional)make generating a new universe cost money
   add more enemies
   add more player ships
 (optional)make price changes update constantly
 (optional)bleed damage to nearby parts (visual only)
 **/
static int sprites2[][] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 1, 0, 0, 0, 0, 0, 0, 1, 9, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 1, 9, 9, 9, 9, 9, 9, 1, 1, 1, 9, 9, 9, 9, 1, 1}
  , {1, 1, 10, 10, 10, 10, 1, 1, 1, 10, 10, 10, 10, 10, 10, 1, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 10, 10, 10, 10, 0, 0, 0, 0, 0, 10, 10, 10, 0, 0, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 0, 0, 1, 1}
  , {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 0, 11, 11, 11, 11, 0, 0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 11, 1, 11, 11, 11, 11, 11, 11, 1, 1, 1, 11, 11, 11, 11, 1, 1}
  , {1, 1, 12, 12, 12, 12, 1, 1, 1, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 12, 12, 12, 0, 0, 0, 12, 12, 12, 12, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0}
  , {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1}
  , {4, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 3, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 3, 0, 0, 0, 0, 0, 0, 4}
  , {3, 0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 3}
  , {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 5, 5, 5, 5, 1, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 5, 5, 5, 5, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1}
  , {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 2, 2, 1, 0, 0, 0, 0, 1, 2, 6, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 7, 0, 1, 0, 0, 0, 0, 0, 0, 1}
  , {13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13}
  //fleet carrier
  , {13, 0, 0, 0, 0, 0, 0, 13, 13, 41, 0, 2, 2, 0, 43, 13, 1, 90, 41, 2, 2, 43, 92, 1, 1, 1, 13, 2, 2, 13, 1, 1, 1, 1, 13, 6, 6, 13, 1, 1, 1, 91, 13, 13, 13, 13, 89, 1, 13, 13, 92, 1, 1, 90, 13, 13, 13, 13, 1, 1, 1, 1, 13, 13}
  , {13, 13, 13, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13, 1, 90, 13, 2, 2, 13, 13, 13, 1, 1, 13, 2, 2, 13, 13, 13, 1, 1, 13, 6, 2, 13, 13, 13, 1, 91, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13}
  , {74, 13, 1, 1, 1, 1, 13, 13, 8, 74, 89, 1, 1, 91, 13, 13, 8, 8, 74, 13, 13, 13, 13, 13, 8, 8, 8, 8, 8, 5, 2, 2, 8, 8, 8, 8, 8, 5, 2, 2, 8, 8, 8, 8, 8, 74, 13, 13, 8, 8, 8, 8, 8, 8, 74, 13, 8, 8, 8, 8, 8, 8, 8, 74}
  , {13, 13, 1, 1, 1, 1, 13, 13, 13, 13, 89, 1, 1, 91, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 10, 10, 13, 13, 13, 2, 2, 2, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13}
  , {8, 8, 8, 8, 8, 8, 8, 75, 8, 8, 8, 8, 8, 8, 75, 13, 8, 8, 8, 8, 8, 75, 13, 13, 8, 8, 8, 8, 8, 5, 2, 2, 8, 8, 8, 8, 8, 5, 2, 2, 8, 8, 75, 13, 13, 13, 13, 13, 8, 75, 92, 1, 1, 90, 13, 13, 75, 13, 1, 1, 1, 1, 13, 13}
  , {74, 13, 1, 1, 1, 1, 13, 13, 8, 74, 89, 1, 1, 91, 13, 13, 8, 8, 74, 13, 13, 13, 92, 1, 8, 8, 8, 74, 13, 13, 1, 1, 8, 8, 8, 8, 74, 13, 1, 1, 8, 8, 8, 8, 8, 74, 89, 1, 8, 8, 8, 8, 8, 8, 74, 13, 8, 8, 8, 8, 8, 8, 8, 74}
  , {13, 13, 1, 1, 1, 1, 13, 13, 13, 13, 89, 1, 1, 91, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 10, 10, 2, 2, 2, 2, 2, 2, 11, 11, 2, 2, 2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 92, 1, 1, 90, 13, 13, 13, 13, 1, 1, 1, 1, 13, 13}
  , {74, 13, 1, 1, 1, 1, 13, 76, 8, 74, 89, 1, 1, 91, 76, 8, 8, 8, 74, 13, 13, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {13, 13, 1, 1, 1, 1, 13, 13, 13, 13, 89, 1, 1, 91, 13, 13, 1, 90, 13, 13, 13, 13, 92, 1, 1, 1, 13, 13, 13, 13, 1, 1, 1, 1, 13, 13, 13, 13, 1, 1, 1, 91, 13, 13, 13, 13, 89, 1, 13, 13, 92, 1, 1, 90, 13, 13, 13, 13, 1, 1, 1, 1, 13, 13}
  , {13, 13, 13, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13, 1, 90, 13, 2, 2, 13, 13, 13, 1, 1, 13, 2, 2, 13, 13, 13, 1, 1, 13, 6, 2, 13, 13, 13, 1, 91, 13, 13, 13, 13, 13, 13, 13, 13, 92, 1, 1, 90, 13, 13, 13, 13, 1, 1, 1, 1, 13, 13}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 13, 13, 73, 8, 8, 8, 75, 92, 1, 1, 90, 73, 8, 75, 13, 1, 1, 1, 1, 13, 73}
  //infinite damage
  , {8, 8, 8, 75, 92, 1, 1, 1, 8, 75, 13, 92, 1, 28, 0, 1, 75, 92, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 74, 89, 1, 1, 1, 1, 1, 1, 8, 74, 13, 89, 1, 25, 0, 1, 8, 8, 8, 74, 89, 1, 1, 1}
  , {1, 1, 1, 2, 2, 1, 1, 1, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1, 2, 2, 1, 0, 1, 2, 2, 2, 11, 11, 1, 0, 1, 2, 2, 2, 10, 10, 1, 0, 1, 1, 1, 1, 2, 2, 1, 0, 1, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1, 2, 2, 1, 1, 1}
  , {1, 1, 1, 2, 2, 1, 1, 1, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1, 2, 2, 1, 0, 1, 2, 2, 2, 2, 11, 1, 0, 1, 2, 2, 2, 2, 11, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1}
  , {74, 89, 1, 1, 1, 1, 1, 1, 8, 74, 89, 1, 31, 26, 1, 1, 8, 8, 74, 89, 1, 25, 26, 1, 8, 8, 8, 74, 89, 1, 22, 1, 8, 8, 8, 8, 74, 89, 1, 1, 8, 8, 8, 8, 8, 74, 89, 1, 8, 8, 8, 8, 8, 8, 74, 89, 8, 8, 8, 8, 8, 8, 8, 74}
  , {8, 8, 8, 8, 8, 8, 8, 75, 8, 8, 8, 8, 8, 8, 75, 92, 8, 8, 8, 8, 8, 75, 92, 1, 8, 8, 8, 8, 75, 92, 16, 1, 8, 8, 8, 75, 92, 16, 19, 16, 8, 8, 75, 92, 16, 28, 27, 1, 8, 75, 92, 16, 31, 27, 1, 1, 75, 92, 1, 1, 16, 1, 1, 1}
  , {73, 8, 8, 8, 8, 8, 8, 8, 90, 73, 8, 8, 8, 8, 8, 8, 1, 90, 73, 8, 8, 8, 8, 8, 1, 1, 90, 73, 8, 8, 8, 8, 1, 19, 1, 90, 73, 8, 8, 8, 1, 25, 26, 1, 90, 73, 8, 8, 1, 1, 25, 20, 1, 90, 73, 8, 1, 1, 1, 1, 1, 1, 90, 73}
  , {1, 1, 1, 1, 1, 1, 91, 76, 1, 1, 28, 20, 1, 91, 76, 8, 1, 28, 27, 1, 91, 76, 8, 8, 1, 22, 1, 91, 76, 8, 8, 8, 1, 1, 91, 76, 8, 8, 8, 8, 1, 91, 76, 8, 8, 8, 8, 8, 91, 76, 8, 8, 8, 8, 8, 8, 76, 8, 8, 8, 8, 8, 8, 8}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 2, 2, 2, 2, 10, 1, 0, 1, 2, 2, 2, 2, 10, 1, 0, 1, 1, 1, 1, 2, 2, 1, 0, 1, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1, 2, 2, 1, 1, 1}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 12, 12, 2, 2, 2, 2, 1, 2, 6, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1}
//healer  
, {8, 8, 8, 8, 5, 11, 0, 0, 8, 8, 59, 1, 1, 1, 1, 1, 8, 59, 91, 13, 13, 13, 92, 1, 59, 91, 13, 13, 13, 92, 28, 0, 1, 13, 13, 13, 13, 1, 14, 14, 58, 90, 13, 13, 13, 89, 25, 0, 8, 58, 90, 13, 13, 13, 89, 1, 8, 8, 58, 1, 1, 1, 1, 1}
  , {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 28, 0, 26, 16, 28, 0, 26, 1, 0, 0, 0, 0, 0, 0, 0, 0, 14, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 27, 1, 25, 0, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1}
 // , {0, 0, 0, 0, 0, 0, 0, 10, 1, 1, 1, 1, 1, 1, 1, 15, 28, 0, 26, 1, 1, 1, 1, 1, 0, 0, 0, 0, 26, 1, 1, 1, 14, 14, 14, 14, 14, 10, 1, 1, 0, 0, 0, 0, 27, 6, 1, 1, 25, 0, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
, {0, 0, 0, 0, 0, 0, 10, 57, 1, 1, 1, 1, 1, 1, 15, 1, 28, 0, 26, 1, 1, 1, 1, 1, 0, 0, 0, 0, 26, 1, 1, 1, 14, 14, 14, 14, 14, 10, 1, 1, 0, 0, 0, 0, 27, 6, 1, 1, 25, 0, 27, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 60} 
//dodger  
, {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 8, 8, 8, 8, 8, 75, 13, 13, 8, 8, 8, 75, 13, 13, 1, 1, 8, 75, 13, 13, 13, 13, 13, 13, 8, 8, 5, 2, 2, 2, 2, 2}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 2, 2, 2, 2, 2}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 13, 13, 13, 13, 13, 13, 13, 73, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 1, 1, 2, 2, 2, 2, 10, 13, 1, 1}
  , {8, 74, 13, 13, 13, 13, 13, 13, 8, 8, 8, 74, 13, 13, 1, 1, 8, 8, 8, 8, 8, 74, 13, 13, 8, 8, 8, 8, 8, 8, 8, 74, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {13, 13, 13, 13, 15, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
//rapid fire
, {8, 8, 8, 8, 8, 59, 1, 1, 8, 75, 92, 1, 1, 1, 1, 1, 8, 8, 5, 5, 2, 2, 2, 2, 8, 74, 64, 64, 64, 89, 1, 1, 8, 8, 8, 8, 8, 74, 64, 64, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 80, 80, 8, 75, 80, 80, 80, 92, 1, 1, 8, 8, 5, 5, 2, 2, 2, 2, 8, 74, 89, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 58, 1, 1}
  , {1, 2, 1, 1, 48, 48, 48, 48, 1, 2, 1, 1, 91, 80, 80, 80, 2, 11, 1, 91, 76, 8, 8, 8, 1, 1, 91, 76, 8, 8, 8, 8, 80, 64, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {80, 89, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 80, 92, 1, 1, 1, 1, 1, 1}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 13, 13, 73, 8, 8, 8, 8, 8, 1, 1, 90, 73, 8, 8, 8, 8, 2, 10, 1, 90, 73, 8, 8, 8, 1, 2, 1, 1, 90, 13, 13, 13, 1, 2, 1, 1, 48, 48, 48, 48}
  , {1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 12, 2, 2, 10, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 15, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 9, 2, 2, 2, 2, 11, 1, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 10, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 12, 10, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 15, 1, 2, 1, 1, 2, 1, 9, 2, 2, 11, 1, 1, 2, 1, 1, 1, 1, 1, 1}
  , {91, 2, 1, 1, 1, 1, 1, 1, 92, 2, 12, 2, 2, 2, 10, 89, 1, 2, 15, 2, 2, 2, 2, 90, 0, 9, 11, 2, 2, 2, 11, 1, 0, 12, 10, 2, 2, 2, 10, 1, 1, 2, 12, 2, 10, 2, 2, 91, 89, 2, 9, 2, 15, 2, 11, 92, 90, 2, 1, 1, 1, 1, 1, 1}
  , {8, 8, 8, 8, 8, 8, 8, 75, 8, 8, 8, 75, 13, 13, 13, 13, 8, 8, 8, 0, 0, 0, 10, 92, 8, 8, 8, 13, 13, 13, 9, 2, 8, 8, 8, 13, 13, 13, 12, 2, 8, 8, 8, 0, 0, 0, 11, 89, 8, 8, 8, 74, 13, 13, 13, 13, 8, 8, 8, 8, 8, 8, 8, 74}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 8, 8, 8, 8, 8, 75, 13, 92, 8, 8, 8, 75, 13, 92, 48, 48, 8, 75, 13, 92, 48, 48, 48, 48, 13, 92, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48}
  , {1, 1, 1, 1, 1, 1, 1, 1, 13, 89, 1, 1, 1, 1, 1, 1, 8, 74, 13, 89, 1, 1, 1, 1, 8, 8, 8, 74, 13, 89, 1, 1, 8, 8, 8, 8, 8, 74, 13, 89, 8, 8, 8, 8, 8, 8, 8, 74, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {1, 91, 64, 76, 8, 8, 8, 8, 13, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 64, 73, 8, 8, 8, 8, 8, 8, 1, 90, 64, 73, 8, 8, 8, 8}
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 1, 80, 1, 1, 1, 1, 64, 1, 1, 80, 1, 1, 1, 91, 76, 1, 1, 80, 1, 1, 1, 64, 8, 1, 1, 80, 1, 1, 1, 64, 8, 1, 1, 80, 1, 1, 91, 76, 8, 1, 1, 80, 1, 1, 64, 8, 8, 1, 1, 80, 1, 91, 76, 8, 8, 1, 1, 80, 91, 76, 8, 8, 8}
  , {1, 1, 80, 90, 73, 8, 8, 8, 1, 1, 80, 1, 90, 73, 8, 8, 1, 1, 80, 1, 1, 64, 8, 8, 1, 1, 80, 1, 1, 90, 73, 8, 1, 1, 80, 1, 1, 1, 64, 8, 1, 1, 80, 1, 1, 1, 64, 8, 1, 1, 80, 1, 1, 1, 90, 73, 1, 1, 80, 1, 1, 1, 1, 80}
  , {1, 91, 92, 1, 1, 1, 1, 13, 91, 92, 1, 1, 1, 91, 86, 13, 92, 1, 1, 1, 91, 80, 92, 13, 1, 1, 91, 83, 80, 92, 87, 13, 1, 1, 90, 86, 80, 89, 82, 13, 89, 1, 1, 1, 90, 80, 89, 13, 90, 89, 1, 1, 1, 90, 83, 13, 1, 90, 89, 1, 1, 1, 1, 13}
  //charger
, {1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 12, 7, 2, 2, 2, 2, 1, 12, 0, 0, 2, 2, 2, 2, 1, 7, 0, 26, 1, 1, 1, 1, 1, 7, 0, 25, 1, 1, 1, 1, 1, 9, 0, 0, 2, 2, 2, 2, 1, 9, 9, 7, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1}
, {1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1}
  , {1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 7, 10, 10, 1, 2, 2, 2, 2, 0, 0, 10, 1, 1, 1, 1, 1, 1, 0, 7, 1, 1, 1, 1, 1, 1, 0, 7, 1, 2, 2, 2, 2, 0, 0, 11, 1, 2, 2, 2, 2, 7, 11, 11, 1, 1, 1, 1, 1, 1, 1, 15, 1}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 13, 13, 13, 13, 13, 73, 8, 8, 2, 2, 10, 10, 90, 13, 73, 8, 1, 1, 1, 15, 1, 90, 13, 73}
  , {1, 1, 12, 10, 1, 91, 13, 76, 2, 2, 11, 15, 91, 13, 76, 8, 13, 13, 13, 13, 64, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 13, 13, 13, 13, 13, 13, 13, 13, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 13, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1}
  , {58, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 5, 2, 2, 2, 2, 8, 8, 74, 13, 13, 13, 13, 13, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
, {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 13, 13, 13, 13, 13, 8, 8, 8, 5, 2, 2, 2, 2, 59, 1, 1, 1, 1, 1, 1, 1}


  , {1, 1, 1, 13, 8, 8, 8, 8, 1, 91, 80, 13, 73, 8, 8, 8, 80, 92, 1, 90, 13, 8, 8, 8, 1, 1, 1, 1, 13, 8, 8, 8, 1, 1, 1, 1, 13, 8, 8, 8, 80, 89, 1, 91, 13, 8, 8, 8, 1, 90, 80, 13, 76, 8, 8, 8, 1, 1, 1, 13, 8, 8, 8, 8}
  
//fires backwards  
, {74, 13, 13, 13, 13, 13, 13, 13, 8, 8, 74, 13, 13, 13, 13, 13, 8, 8, 8, 8, 74, 13, 13, 13, 8, 8, 8, 8, 8, 8, 74, 13, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 13, 8, 8, 8, 8, 75, 13, 13, 13, 8, 8, 75, 13, 13, 13, 13, 13, 75, 13, 13, 13, 13, 13, 13, 13}
  , {13, 13, 13, 13, 13, 13, 13, 13, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 7, 7, 7, 8, 8, 8, 8, 0, 0, 7, 0, 8, 8, 8, 8, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 13, 13, 13, 13, 13, 13, 13, 13}
  , {74, 64, 13, 13, 13, 13, 13, 13, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 7, 7, 7, 7, 7, 7, 75, 64, 13, 13, 13, 13, 13, 13}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 75, 13, 13, 64, 75, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 2, 2, 2, 2, 2, 2, 13, 6, 12, 2, 2, 2, 2, 2, 13, 13, 9, 2, 2, 2, 2, 2}
  , {13, 12, 2, 2, 2, 2, 2, 2, 13, 6, 12, 2, 2, 2, 2, 2, 13, 13, 9, 2, 2, 2, 2, 2, 13, 13, 13, 13, 13, 13, 13, 13, 74, 64, 64, 64, 64, 64, 64, 64, 8, 8, 8, 8, 74, 64, 64, 64, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}

, {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 73, 8, 8, 8, 8, 8, 8, 8, 13, 64, 64, 64, 73, 8, 8, 8, 13, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 2, 2, 2, 10, 13, 2, 2, 2, 2, 2, 2, 11, 13, 2, 2, 2, 2, 2, 2, 10, 13}
  , {2, 2, 2, 2, 2, 10, 2, 13, 2, 2, 2, 2, 2, 11, 2, 13, 2, 2, 2, 2, 2, 2, 11, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 64, 64, 64, 76, 8, 8, 8, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {13, 13, 13, 13, 13, 13, 2, 13, 7, 7, 7, 7, 7, 7, 9, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 12, 7, 13, 13, 13, 13, 13, 13, 2, 13}
  , {13, 64, 8, 8, 8, 8, 8, 8, 13, 76, 8, 8, 8, 8, 8, 8, 13, 8, 8, 8, 8, 8, 8, 8, 76, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
  , {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 73, 8, 8, 8, 8, 8, 8, 8, 13, 8, 8, 8, 8, 8, 8, 8, 13, 73, 8, 8, 8, 8, 8, 8, 13, 64, 8, 8, 8, 8, 8, 8}
  , {13, 13, 73, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 13, 13, 76, 8, 8, 8, 8, 8}
};
float shiplvl1[][]={

  //old
  {0, 0, 0, 0, 0, 0, 0, 4, 1, 1, 2, 0, 9, 6, 6, 6, 6, 3, 3, 1, 1, 1, 1, 10, 0, 3, 1, 1, 5, 0, 0, 0, 0, 0, 0, 0}, 
  {5, 6, 6, 6, 6, 3, 2, 6, 6, 6, 3, 10, 6, 6, 6, 6, 4, 3, 5, 6, 6, 6, 6, 4, 2, 6, 6, 6, 6, 3, 1, 1, 1, 1, 1, 10}
};
float shiplvl2[][]={
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 45, 48, 56, 23, 23, 23, 52, 51, 70, 23, 23, 23, 44, 46, 55, 23, 23, 23, 23, 23, 23, 23, 23, 23}, 
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 69, 64, 23, 23, 23, 23, 61, 63, 23, 23, 23, 23, 68, 65, 23, 23, 23, 23, 23, 23, 23}, 
  //old
  {9, 6, 6, 6, 3, 1, 9, 6, 6, 3, 10, 1, 9, 6, 3, 10, 1, 1, 9, 3, 10, 1, 1, 1, 3, 10, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1}, 
  {9, 6, 6, 6, 6, 3, 1, 1, 1, 1, 1, 10, 9, 6, 6, 6, 6, 3, 1, 1, 1, 1, 1, 10, 9, 6, 6, 6, 6, 3, 1, 1, 1, 1, 1, 10}, 
  {3, 3, 1, 1, 1, 1, 4, 10, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 4, 10, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 4, 10, 1, 1, 1, 1}
};
float shiplvl3[][]={

  //old
  {9, 6, 6, 6, 6, 3, 6, 6, 6, 6, 3, 10, 1, 1, 1, 1, 10, 1, 9, 6, 6, 6, 6, 3, 6, 6, 6, 6, 3, 10, 1, 1, 1, 1, 10, 1}, 
  {3, 5, 6, 6, 6, 3, 4, 10, 1, 1, 1, 5, 3, 3, 6, 6, 6, 4, 4, 4, 6, 6, 6, 3, 3, 5, 6, 6, 6, 4, 4, 10, 1, 1, 1, 1}
};
String alert = "Starting String";
int alerttime = 0;
boolean keys[] = {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};
boolean keys2[] = {true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true };
char keysindex[] = {'w', 'a', 's', 'd', '8', '4', '5', '6', ' ', '+', '2', '-', '3', '-', '1', '-', 'e', 'm'};
//                   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15  16   17
String keysdesc[] = {"Move Up", "Move Down", "Move Left", "Move Right", "Toggle Pivots", "Exit to Map", "Fire All", "Fire First", "Fire Second", "Fire Third"};
char controlindex[] = {'W', 'S', 'A', 'D', 'E', 'M', ' ', '1', '2', '3', };
float bosses[][] = {
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 35, 36, 36, 36, 36, 37, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23}, //self healer 1
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 38, 39, 40, 23, 23, 23, 41, 42, 43, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23}, //dodges 2
  //damages every part 6
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 72, 75, 77, 75, 77, 81, 74, 73, 79, 73, 79, 82, 71, 76, 78, 76, 78, 80, 23, 23, 23, 23, 23, 23}, //fires backwards 3
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 45, 48, 56, 23, 45, 48, 53, 49, 59, 52, 47, 51, 57, 57, 60, 23, 44, 46, 54, 50, 58, 23, 23, 23, 44, 46, 55}, //rapid fire 4
  {23, 23, 23, 23, 23, 23, 69, 67, 67, 67, 67, 64, 61, 62, 62, 62, 62, 63, 61, 62, 62, 62, 62, 63, 68, 66, 66, 66, 66, 65, 23, 23, 23, 23, 23, 23}, //stores lasers 5
  {23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 23, 17, 19, 19, 19, 16, 23, 18, 21, 21, 21, 22, 23, 23, 20, 20, 20, 20, 23, 23, 23, 23, 23, 23}, //placeholder (damages every part)
  {23, 23, 23, 23, 29, 30, 23, 23, 29, 33, 34, 32, 25, 34, 34, 34, 34, 26, 23, 23, 28, 33, 34, 27, 23, 23, 23, 23, 28, 31, 23, 23, 23, 23, 23, 23}, //infinite damage 7
  {23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 23, 17, 19, 19, 19, 16, 23, 18, 21, 21, 21, 22, 23, 23, 20, 20, 20, 20, 23, 23, 23, 23, 23, 23}, //fleet carrier 8
  {23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23}//final boss placeholder 



  //{23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 23, 17, 19, 19, 19, 16, 23, 18, 21, 21, 21, 22, 23, 23, 20, 20, 20, 20, 23, 23, 23, 23, 23, 23}, //fleet carrier(duplicate for testing purposes)
};
float ships[][] = {
  {64, 64, 64, 64, 64, 64, 64, 67, 64, 64, 64, 64, 64, 1, 5, 7, 64, 64, 64, 1, 6, 66, 64, 64, 64, 68, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64}, //starter ship
  {64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 1, 5, 7, 7, 7, 7, 1, 6, 66, 68, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64}, //long ship
};
float ship[] =
  {64, 64, 64, 64, 64, 64, 64, 67, 64, 64, 64, 64, 64, 1, 5, 7, 64, 64, 64, 1, 6, 66, 64, 64, 64, 68, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64};
float shipshape[]=new float[36];
float ship2[] = {
  3, 3, 3, 3, 3, 3, 
  10, 10, 10, 10, 10, 10, 
  1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1};
float damagemap21[][][][]= new float[6][6][8][8];
float damagemap22[][][][]= new float[6][6][8][8];
float damagemap[] = {
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100};
float damagemap2[] = {
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  1000, 1000, 1000, 1000, 1000, 1000, 
  100, 100, 100, 100, 100, 100, 
  10, 10, 100, 100, 100, 100, 
  1, 1, 100, 100, 100, 100};
float healthmap[] = {
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100};
float healthmap2[] = {
  100, 100, 100, 100, 100, 100, 
  100, 100, 100, 100, 100, 100, 
  1000, 1000, 1000, 1000, 1000, 1000, 
  100, 100, 100, 100, 100, 100, 
  10, 10, 100, 100, 100, 100, 
  1, 1, 100, 100, 100, 100};
int graph[][] = new int[2][100];
float planetmap[][] = new float[120][120];
float planettexturemap[][] = new float[1000][1000];
static int planettype=0;
static int planetsize = 80;
float planetsmooth = 80;
static float planetx=700;
static float planety=500;
static boolean reset = true;
String tooltips[] = {"Low Threat", "Medium Threat", "High Threat", "Extreme Threat"};
float testvar=0;
float noisestep=0.05;                     //0  1      2         3      4       5     6
float projectiles[][] = new float[400][7];//x, y, direction, damage, pierce, speed ,type(0-projectile 1-laser)
//planet gravity:                         //x, y, direction, damage, pierce, yvel , xvel
static float cannon[][] = {{0, 0, 1, 0}, {10, 0, 1, 0}, {0, 10, 1, 0}};//new float[3][3];//x,y,active(0=false,1=true)
static float cannon2[][] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
float damageamount=0.5;
float healamount=0.1;
float projectilespeed = 3;
float laserspeed=5;
int stepspertick=2;
int laserstepspertick=25;
int steps=0;
int projectilesnumb=0;
float temppart=0;
int tempaction=0;
static float shipx=300;
static float shipy=500;
float shipx2=750;
float shipy2=500;
float shipu=1;
float shipd=1;
float shipl=1;
float shipr=2;
float targetx=0;
float targety=0;
int sizex=6;
int sizey=6;
float timesinceshot = 0;
int tempx=0;
int tempy=0;
float tempvar=0;
int tempvar2=0;
int tempvar3=0;
float tempvar4=0;
float tempvar5=0;
int tempvar6=0;
int tempvar7=0;
float tempvar8=0;
float tempvar9=0;
float tempvar10=0;
int tempvar11=0;
float tempvar12=0;
float px2 =0;
float py2 =0;
float px=0;
float py=0;
float pd=0;
float pd2=0;
float temparray[]={0, 0, 0, 0};
float zoom= 2;
float nodezoom=4;
int doors=4;
int delay=0;
int nextdelay=0;
int firerate=300;
int delay2=0;
int firerate2=300;
int nextdelay2=0;
int skip=0;
static int scene = 3;
static int scene2 = 0;
String message="Test Message Test Message";
int money=1000;
int shipcost=0;
int shipcost2=0;
int index = 0;
int index1=0;
int index2=0;
int index3=0;
int enemylvl=0;
int enemydmg=0;
boolean shops=false;
int stock=1;
float price = 1;
int lastscene=3;
boolean escape=false;
boolean released = false;
boolean update = true;
boolean refresh = true;
boolean emptyslot=false;
boolean slot1=true;
boolean slot2=true;
boolean slot3=true;
int targetMPF=60;
int refreshx=round(width*((250-(float)planetsize)/500)/zoom);
int refreshy=round(height*((250-(float)planetsize)/500)/zoom);
boolean research[] = new boolean[25];
boolean planets = false;
float scale = 5;
String mousetext="";
int maxdrones=50;
float dronesize=3;
float dronesize2=3;
float dronedelay=200;
float dronespeed = 0.2;
float dronedamage = 3;
float drones[][] = new float[maxdrones][8];//x y delay targetx targety xvel yvel (holding leg)
int menutime=0;
int pages=5;
int currentpage=0;
int pages2=1;
int currentpage2=0;
boolean tutorial[] = {false,false,false,false,false,false};// ship designer - part designer - research - combat - planet - shop
boolean paused = false;
int tutorialtime=0;
boolean dontmove=false;
int boss = 0;
int defeatedbosses=0;
float bosshealth = 1000;
boolean bossindex[] = new boolean[bosses.length];
float animationtime=0;
float animationvel=0;
float legs[][]=new float[8][5];//x,y,tx,ty,tID
float legdis=0;
float legareax=0;
float legareay=0;
int oldleg=0;
int secondpart=0;
int secondpart2=0;
//bosses:                              implementation difficulty:
//max drones                           easy   1
//infinite damage                      easy   2
//self-healer                          easy   3
//rapid fire                           easy   4
//dodges projectiles                   medium 5
//fires backwards                      medium 6
//blinds player                        easy   7
//damages every player part at once    medium 8
//planet spider                        hard   9


//settings
boolean debug=false;
boolean cheat=true;
boolean simpledrones=false;
float trailsize=5;//setting
int particleamount=5;//setting
float particlespread=1;
float particlemaxsize=10;
float particleminsize=5;
float particlespeed=2;
float brokenalpha=100;
int galaxy=77484;//seed for current map 77484 5
float dmg = 5;//damage assigned to newly created projectiles(only applies to player ship)
float speed = 2;//speed of player ship
float acceleration = 10;
float speed2 = 2;
float acceleration2 = 10;
float xvel = 0;
float yvel = 0;
float xvel2= 0;
float yvel2= 0;
float knockback=2;//higher means less knockback     10 is default
boolean backdrop = true;//setting
boolean visited[] = new boolean[20];
int objectnumb = 0;
int currentobject =0;
float zoomx=0;
float zoomy=0;
float zoomamount=1;
float zoomspeed=1.05;//1.05 is default   1.2 is extremely fast
float zoomid=0;
float currentid=0;
float fireratemodifier=0.5;//lower means more damage higher means faster firerate (maintains DPS)
float healthmodifier=0.25;//higher means more health (does not maintain DPS)
//background variables
static float GALseed1=2;
static float GALseed2=3;
static float GALtempvar1=0;
static float GALtempvar2=0;
static float GALtempvar3=0;
static float GALscale=10;
static float GALnoisescale=30;
static float GALnoisescale2=15;
static float GALstaramount=3;
static float background[][][] = new float[300][150][2];//red blue
static int stars[][] = new int[20000][3];//x,y,size
static boolean randomstars=false;
static int starnum=0;
//Debug Controls
//L - use enemy parts
//O - print current sprite
//R T - change planet size
float particles[][]=new float[300][6];//damage particles
float particles2[][]=new float[20][4];//healing particles  //x,y,size,maxsize
static float particles3[][]= new float[2000][5];//x,y,size,initial size,type  //trail particles
float particles4[][] = new float[5000][5];//x,y,xvel,yvel,size
int particlerepetition=10;
int projectileindex = 0;
int particleindex=0;
int particleindex2=0;
int particleindex3=0;
int particleindex4=0;
static boolean breakloop=false;
//0-empty space
//1-white-damagable
//2-teal-damage increaser effect
//3-grey-pivot
//4-grey-pivot
//5-yellow-primer
//6-green-not damagable(cannon)
//7-blue-focusing effect
//8-white-not damagable
//9-teal-NE corner
//10-teal-SW corner
//11-teal-NW corner
//12-teal-SE corner
//13-grey-armour
//14-pink-healing effect
static String name[]={
  "Empty", //0
  "Hull", //1
  "Damage Augment", //2
  "Pivot 1", //3
  "Pivot 2", //4
  "Primer", //5
  "Kinetic Emitter", //6
  "Lens", //7
  "Window", //8
  "NE Reflector", //9
  "SW Reflector", //10
  "NW Reflector", //11
  "SE Reflector", //12
  "Armour", //13
  "Healing Augment", //14
  "Laser Emitter"//15
};
static boolean locked[]={false, false, true, true, true, true, true, true, true, false, false, false, false, true, true, true};
public static int pixelhealth[]={1, 10, 2, 5, 5, 3, 50, 2, 0, 5, 5, 5, 5, 50, 2, 0};
int pcost[] =                 {0, 1, 20, 25, 25, 50, 100, 20, 1, 10, 10, 10, 10, 50, 1, 0};
int prefabcost[] = {0, 128, 163, 163, 163, 163, 308, 48};
static int prefabs[][] = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}//empty 0
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}//full 1
  , {1, 1, 0, 0, 0, 0, 0, 0, 1, 9, 0, 0, 0, 0, 0, 0, 9, 9, 9, 0, 0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0, 9, 9, 9, 9, 9, 0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 1, 9, 9, 9, 9, 9, 9, 1, 1, 1, 9, 9, 9, 9, 1, 1}//NE corner 2
  , {1, 1, 10, 10, 10, 10, 1, 1, 1, 10, 10, 10, 10, 10, 10, 1, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 10, 10, 10, 10, 10, 0, 0, 0, 0, 10, 10, 10, 10, 0, 0, 0, 0, 0, 10, 10, 10, 0, 0, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 0, 0, 1, 1}//SW corner 3 
  , {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 0, 11, 11, 11, 0, 0, 0, 0, 11, 11, 11, 11, 0, 0, 0, 11, 11, 11, 11, 11, 0, 0, 11, 11, 11, 11, 11, 11, 1, 11, 11, 11, 11, 11, 11, 1, 1, 1, 11, 11, 11, 11, 1, 1}//NW corner 4
  , {1, 1, 12, 12, 12, 12, 1, 1, 1, 12, 12, 12, 12, 12, 12, 1, 12, 12, 12, 12, 12, 12, 0, 0, 12, 12, 12, 12, 12, 0, 0, 0, 12, 12, 12, 12, 0, 0, 0, 0, 12, 12, 12, 0, 0, 0, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0}//SE corner 5
  , {1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 2, 0, 1, 1, 1, 1, 1, 6, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}//cannon 6
  , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}//barrel 7
  //, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}//testsprite
  //, {1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1}//testsprite
};
static int prebuilt[][] = {
  {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
, {1, 57, 8, 8, 8, 8, 8, 8, 1, 1, 1, 57, 8, 8, 8, 8, 1, 1, 1, 1, 1, 57, 8, 8, 1, 1, 1, 1, 1, 1, 1, 57, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 60, 1, 1, 1, 1, 1, 60, 8, 8, 1, 1, 1, 60, 8, 8, 8, 8, 1, 60, 8, 8, 8, 8, 8, 8}
, {8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 57, 8, 8, 8, 8, 8, 8, 1, 1, 1, 57, 8, 8, 8, 8, 1, 1, 1, 1, 1, 57, 8, 8, 1, 1, 1, 1, 1, 1, 1, 57}
, {1, 1, 1, 1, 1, 1, 1, 60, 1, 1, 1, 1, 1, 60, 8, 8, 1, 1, 1, 60, 8, 8, 8, 8, 1, 60, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}
, {58, 1, 1, 1, 1, 1, 1, 1, 8, 58, 1, 1, 1, 1, 1, 1, 8, 8, 58, 1, 1, 1, 1, 1, 8, 8, 8, 58, 1, 1, 1, 1, 8, 8, 8, 8, 58, 1, 1, 1, 8, 8, 8, 8, 8, 58, 1, 1, 8, 8, 8, 8, 8, 8, 58, 1, 8, 8, 8, 8, 8, 8, 8, 58}
, {1, 1, 1, 1, 1, 1, 1, 60, 1, 1, 1, 1, 1, 1, 60, 8, 1, 1, 1, 1, 1, 60, 8, 8, 1, 1, 1, 1, 60, 8, 8, 8, 1, 1, 1, 60, 8, 8, 8, 8, 1, 1, 60, 8, 8, 8, 8, 8, 1, 60, 8, 8, 8, 8, 8, 8, 60, 8, 8, 8, 8, 8, 8, 8}
, {57, 8, 8, 8, 8, 8, 8, 8, 1, 57, 8, 8, 8, 8, 8, 8, 1, 1, 57, 8, 8, 8, 8, 8, 1, 1, 1, 57, 8, 8, 8, 8, 1, 1, 1, 1, 57, 8, 8, 8, 1, 1, 1, 1, 1, 57, 8, 8, 1, 1, 1, 1, 1, 1, 57, 8, 1, 1, 1, 1, 1, 1, 1, 57}
, {8, 8, 8, 8, 8, 8, 8, 59, 8, 8, 8, 8, 8, 8, 59, 1, 8, 8, 8, 8, 8, 59, 1, 1, 8, 8, 8, 8, 59, 1, 1, 1, 8, 8, 8, 59, 1, 1, 1, 1, 8, 8, 59, 1, 1, 1, 1, 1, 8, 59, 1, 1, 1, 1, 1, 1, 59, 1, 1, 1, 1, 1, 1, 1}
  , {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}


};
static int sprites[][] = new int[80+prebuilt.length][64];

static float spritehealth[]=new float[sprites.length];
static int cost[]= new int[sprites.length];
static float resize=1;//1.5 is default for fullscreen

void setup() {

  //noSmooth();
  //smooth(2);
  //fullScreen();
  size(1000, 1000, P2D);
    //textMode(SCREEN);
    textFont(createFont("Lucida Sans",200,true));
  //for (int i =0; i<ship.length; i++) {
  //ship[i]=bosses[1][i];
  //}
  //generates planet texture
  noiseSeed(round(random(0, 100)));
  
  for (int i = 0; i<planettexturemap.length; i++) {
    for (int j = 0; j<planettexturemap[0].length; j++) {
      planettexturemap[i][j]=noise(((float)i)*noisestep, ((float)j)*noisestep);
    }
  }
  //sets the cost of starting parts
  for (int i = 0; i<prefabs.length; i++) {
    cost[i]=prefabcost[i];
  }
  //adds starting parts to the players part list
  noStroke();

  for (int i = 0; i<prefabs.length; i++) {
    for (int j = 0; j<prefabs[0].length; j++) {
      sprites[i][j]=prefabs[i][j];
    }
  }
  for (int i = 0; i<prebuilt.length; i++) {
    for (int j = 0; j<prebuilt[0].length; j++) {
      sprites[i+64][j]=prebuilt[i][j];
    }
  }
  //calculates damagemap for the first planet the player encounters
  for (int i = 0; i<planetmap.length; i++) {
    for (int j = 0; j<planetmap[0].length; j++) {
      planetmap[i][j]=random(-10, 10);
    }
  }
  for (int i = 0; i<research.length; i++) {
    research[i]=false;
  }
  for (int i = 0; i<bossindex.length; i++) {
    bossindex[i]=true;
  }
  shipcost=0;
  tempvar6=0;
  tempvar11=0;
  cannon[0][2]=0;
  cannon[1][2]=0;
  cannon[2][2]=0;
  cannon2[0][2]=0;
  cannon2[1][2]=0;
  cannon2[2][2]=0;
  cannon2[3][2]=0;
  cannon2[4][2]=0;
  cannon2[5][2]=0;
  for (int i = 0; i<sizey; i++) {
    for (int j = 0; j<sizex; j++) {
      //calculates the cost of the players starting ship
      if (tempvar6!=-1) {
        tempvar6=round(ship[i*sizey+j]);
      }
      if (tempvar11!=-1) {
        tempvar11=round(ship2[i*sizey+j]);
      }
      shipcost+=cost[round(ship[i*sizey+j])];
      //finds where the players cannons are and puts them in a list so that they can be fired
      for (int k = 0; k<8; k++) {
        for (int l = 0; l<8; l++) {

          if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
            if (cannon[0][2]==0) {
              cannon[0][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon[0][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon[0][2]=1;
              if (sprites[tempvar6][k*8+l]==6) {
                cannon[0][3]=0;
              } else {
                cannon[0][3]=1;
              }
            } else if (cannon[1][2]==0) {
              cannon[1][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon[1][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon[1][2]=1;
              if (sprites[tempvar6][k*8+l]==6) {
                cannon[1][3]=0;
              } else {
                cannon[1][3]=1;
              }
            } else if (cannon[2][2]==0) {
              cannon[2][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon[2][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon[2][2]=1;
              if (sprites[tempvar6][k*8+l]==6) {
                cannon[2][3]=0;
              } else {
                cannon[2][3]=1;
              }
            } else {
              message="Too many emitters (3 MAX)";
              scene2=3;
              tempvar6=-1;
            }
          }
          if (tempvar11!=-1&&(sprites2[tempvar11][k*8+l]==6||sprites2[tempvar11][k*8+l]==15)) {
            if (cannon2[0][2]==0) {
              cannon2[0][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[0][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[0][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[0][3]=0;
              } else {
                cannon2[0][3]=1;
              }
            } else if (cannon2[1][2]==0) {
              cannon2[1][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[1][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[1][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[1][3]=0;
              } else {
                cannon2[1][3]=1;
              }
            } else if (cannon2[2][2]==0) {
              cannon2[2][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[2][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[2][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[2][3]=0;
              } else {
                cannon2[2][3]=1;
              }
            } else if (cannon2[3][2]==0) {
              cannon2[3][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[3][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[3][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[3][3]=0;
              } else {
                cannon2[3][3]=1;
              }
            } else if (cannon2[4][2]==0) {
              cannon2[4][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[4][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[4][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[4][3]=0;
              } else {
                cannon2[4][3]=1;
              }
            } else if (cannon2[5][2]==0) {
              cannon2[5][0]=j+(float)l/8+scale/8/8;//+k/8;
              cannon2[5][1]=i+(float)k/8+scale/8/8;//+l/8;
              cannon2[5][2]=1;
              if (sprites2[tempvar11][k*8+l]==6) {
                cannon2[5][3]=0;
              } else {
                cannon2[5][3]=1;
              }
            } else {
              tempvar11=-1;
            }
          }
        }
      }
    }
  }
  //unlocks everything if cheat mode is enabled
  if (cheat) {
    stock=100;
    shops=true;
    planets=true;
    money=10000000;

    for (int i = 0; i<locked.length; i++) {
      locked[i]=false;
    }
  }
  //generates the background image(does not actually draw it onto the screen)
  drawbackground();
}
boolean planetdrawmap[][] = new boolean[500][500];
int numb=-10;
float avg=0;
int pre=0;
float MPF=0;
float maxframerate=30;
//start of main game loop
void draw() {
  System.out.println(damagemap2[18]);
  //System.out.println(delay2);
  //resize=(float)min(height, width)/1000;
  //planetsize++;
  //System.out.println(planetsize);
  //System.out.println(boss);
  //upside down
  //rotate(PI);
  //translate(-1000,-1000);

  //if (debug) {
  //  if (keyPressed&&key=='h') {
  //    surface.setSize(width, height+10);
  //  } else if (keyPressed &&key=='y') {
  //    surface.setSize(width, height-10);
  //  } else if (keyPressed &&key=='g') {
  //    surface.setSize(width-10, height);
  //  } else if (keyPressed &&key=='j') {
  //    surface.setSize(width+10, height);
  //  }
  //}
  
  //System.out.println(index3);
  //System.out.println(maxdrones+" "+boss);
  //unlocks everything if cheat mode was enabled
  if (cheat&&money<1000000) {
    stock=100;
    shops=true;
    planets=true;
    money=10000000;

    for (int i = 0; i<locked.length; i++) {
      locked[i]=false;
    }
  }
  if (debug&&keyPressed&&key=='p') {

    paused=!paused;
  }
  //draws background image
  if (scene==0||scene==3||scene==8||scene==12||scene==-1) {
    noStroke();
    randomSeed((long)GALseed1);
    for (int i = 0; i<width/GALscale; i++) {
      for (int j = 0; j<height/GALscale; j++) {
        if (backdrop&&i<background.length&&j<background[i].length) {
          fill(background[i][j][0], 0, background[i][j][1]);
        } else {
          fill(0, 0, 0);
        }
        square(i*GALscale, j*GALscale, GALscale*1);


        if (backdrop&&randomstars&&i<background.length&&j<background[i].length) {


          for (int k = 0; k<(background[i][j][0]*background[i][j][1])*(GALstaramount/1000); k++) {
            fill(255, 255, 255, (randomGaussian()+0.1)*50);

            square(GALscale*i+random(GALscale), GALscale*j+random(GALscale), random(2));
          }
        }
      }
    }
    if (backdrop) {

      for (int i =0; i<starnum; i++) {

        fill(255, 255, 255, stars[i][2]);
        square(stars[i][0], stars[i][1], 1);
      }
    }
  } else {
    background(50);
  }


//particlerepetition=max(round(mouseY/10),1);
if(scene==0||scene==8){
border(width/2,0,0,height/particlerepetition,200/particlerepetition,0.3);

for(int i=0;i<particles4.length;i++){
if(particles4[i][4]>0){
particles4[i][4]-=0.1;
particles4[i][0]+=particles4[i][2];
particles4[i][1]+=particles4[i][3];
fill(255,255,255,50);
noStroke();
for(int j=0;j<particlerepetition;j++){
square(particles4[i][0],particles4[i][1]+height/particlerepetition*j,particles4[i][4]);
//circle(particles4[i][0],particles4[i][1],particles4[i][4]);
}
}

}
}


  if (boss==9) {
    if (abs(targetx-shipx)+abs(targety-shipy)<50) {
      targetx=random(width*0.6, width*0.9);
      targety=random(height*0.2, height*0.8);
    }
    //if (shipx2<0) {
    //  shipx2=800;
    //}
    //if (shipy2<0) {
    //  shipy2=500;
    //}

    //if (shipy2>5+targety) {
    //  shipy2-=2;
    //}
    //if (shipy2<-5+targety) {
    //  shipy2+=2;
    //}
    //if (shipx2>5+targetx) {
    //  shipx2-=2;
    //}
    //if (shipx2<-5+targetx) {
    //  shipx2+=2;
    //}
    //fill(255, 0, 0);
    //circle(shipx2, shipy2, 400);
    //fill(0, 255, 0);
    //circle(shipx2, shipy2, 150);



    fill(255, 0, 0, 100);
    //circle(shipx2+150, shipy2, 200);
    //circle(shipx2-150, shipy2, 200);
    //circle(shipx2, shipy2+150, 200);
    //circle(shipx2, shipy2-150, 200);
    //circle(shipx2+106.066017118, shipy2+106.066017118, 200);
    //circle(shipx2+106.066017118, shipy2-106.066017118, 200);
    //circle(shipx2-106.066017118, shipy2-106.066017118, 200);
    //circle(shipx2-106.066017118, shipy2+106.066017118, 200);

    planetx=shipx2;
    planety=shipy2;


    xvel2=0;
    yvel2=0;
    for (int i =0; i<legs.length; i++) {
      switch(i) {
      case 0:
        legareax=shipx2+150;
        break;
      case 1:
        legareax=shipx2-150;
        break;
      case 2:
        legareay=shipy2+150;
        break;
      case 3:
        legareay=shipy2-150;
        break;//53.033008589
      case 4:
        legareax=shipx2+106.066017178;
        legareay=shipy2+106.066017178;
        break;
      case 5:
        legareax=shipx2-106.066017178;
        legareay=shipy2+106.066017178;
        break;
      case 6:
        legareax=shipx2-106.066017178;
        legareay=shipy2-106.066017178;
        break;
      case 7:
        legareax=shipx2+106.066017178;
        legareay=shipy2-106.066017178;
        break;
      }



      legdis=sqrt((legs[i][0]-legareax)*(legs[i][0]-legareax)+(legs[i][1]-legareay)*(legs[i][1]-legareay));
      if (legs[i][4]<=-1||numb%(legs.length*30)==i*30||legs[i][4]>maxdrones||(numb%10==1&&(100<legdis))) {
        //oldleg=floor(legs[i][4]);
        if (legs[i][4]!=-1) { 
          drones[floor(legs[i][4])][7]=-1;
        }
        legs[i][4]=-1;
        for (int j = 0; j<maxdrones; j++) {
          legdis=sqrt((drones[j][0]-legareax)*(drones[j][0]-legareax)+(drones[j][1]-legareay)*(drones[j][1]-legareay));
          if (((100>legdis)&&drones[j][7]==-1)) {

            legs[i][4]=j;
            drones[j][7]=i;
            break;
          }
        }
      }
      //System.out.println(legs[i][0]+" "+legs[i][1]+" "+legs[i][2]+" "+legs[i][3]+" "+legs[i][4]);
      if (legs[i][4]!=-1&&scene==8) {
        legs[i][2]=drones[floor(legs[i][4])][0];
        legs[i][3]=drones[floor(legs[i][4])][1];




        if (abs(legs[i][0]-legs[i][2])<15) {
          legs[i][0]=legs[i][2];
          xvel2+=(legs[i][0]-shipx2)/100;
        } else {
          legs[i][0]-=(legs[i][0]-legs[i][2])/(abs(legs[i][1]-legs[i][3])+abs(legs[i][0]-legs[i][2]))*20;
        }
        if (abs(legs[i][1]-legs[i][3])<15) {
          legs[i][1]=legs[i][3];
          yvel2+=(legs[i][1]-shipy2)/100;
        } else {
          legs[i][1]-=(legs[i][1]-legs[i][3])/(abs(legs[i][1]-legs[i][3])+abs(legs[i][0]-legs[i][2]))*20;
        }
      }
      fill(0, 0, 255);
      stroke(0, 0, 255);
      strokeWeight(5);


      //line(legs[i][0], legs[i][1], shipx2, shipy2);
    }
  }

  if (scene2==4) {
    paused=true;
    if (lastscene==14) {

      if (zoomamount>50) {
        if (scene==4) {
          animationtime=0;
          scene=3;
          animationvel=0;
        } else {
          lastscene=3;
          scene2=5;
        }
      } else {
        if (scene==4) {
          zoomamount=(animationvel*animationvel*animationvel/1000+1);
        } else {
          zoomamount*=(1.001*zoomspeed+zoomamount/50);
        }
        if (zoomamount>50) {
          fill(255, 155, 0, 255);
          square(-5, -5, max(width*2, height*2));
        }
      }
    } else if (lastscene==3) {
      //zoomamount-=0.000001;
      zoomamount*=1/(1.001*zoomspeed+zoomamount/50);
      if (zoomamount<=1) {
        zoomamount=1;
        scene2=0;
        paused=false;
      }
    } else if (lastscene!=15) {
      //zoomamount+=0.000001;
      zoomamount*=(1.001*zoomspeed+zoomamount/50);
      if (zoomamount>50) {
        zoomamount=50;
        scene2=0;
        paused=false;
        if (lastscene==0||lastscene==8) {
          scene=-1;
        } else {
          scene=lastscene;
        }
      }
    }
  } else if (scene==3) {
    zoomamount=1;
    zoomx=mouseX;
    zoomy=mouseY;
  }

  mousetext="";
  //calculates and draws alerts
  if (alerttime>0) {  //10 9 8 7 0 0 0
    alerttime--;  //100 99 98 97
    textSize(10);
    stroke(100, 0, 0);
    strokeWeight(2);
    fill(150, 0, 0, 25.5*alerttime);
    rect(textWidth(alert)/20-3, height*0.75-11, textWidth(alert)+4, 14);
    fill(255, 0, 0, 25.5*alerttime);
    text(alert, textWidth(alert)/20, height*0.75);
  }
  textSize(10);
  noStroke();
  //Determines FPS and draws graph if debug mode is enabled
  numb++;
  MPF=millis()-pre;
  if (MPF<(1000/maxframerate)) {
    wait(floor((1000/maxframerate)-MPF));
  }
  if (numb>0) {
    avg=(MPF+avg*numb)/(numb+1);
    graph[0][numb%graph[0].length]=max(round(MPF*10), 1);
    if (numb>30) {
      for (int i=0; i<30; i++) {
        graph[1][numb%graph[0].length]+=graph[0][(numb-i)%graph[0].length];
      }
      graph[1][numb%graph[0].length]/=30;
    }
    //for(int i = 0;i<keys.length;i++){System.out.print(keys[i]+" ");}
    //System.out.println(delay+" "+nextdelay);
    if (debug) {
      for (int i=0; i<graph[0].length; i++) {
        fill(255, 0, 0);
        circle(i, height-graph[0][i]/10, 2);
        fill(0, 255, 0);
        circle(i, height-graph[1][i]/10, 2);
      }
      stroke(255, 255, 255, 255);
      strokeWeight(1);
      line(numb%graph[0].length, height, numb%graph[0].length, height-50);
    }
    fill(255, 255, 255);
    if (debug) {
      text("MPF: "+graph[1][numb%graph[0].length]/10, 10, height-70);
    }
    if (graph[1][numb%graph[0].length]!=0&&debug) {
      text("FPS: "+1000/max(graph[1][numb%graph[0].length]/10, 1), 10, height-60);
    }
    noStroke();
  }
  pre=millis();
  //combat setup
  if (scene==-1) {
    //System.out.println("test");
    resetscene();
    delay=1000;
    delay2=1000;
    for (int i = 0; i<sizex; i++) {
      for (int j = 0; j<sizey; j++) {

        tempx=round(ship[i*sizex+j]);



        tempy=5;
        for (int k = 0; k<8; k++) {
          for (int l = 0; l<8; l++) {
            if ((sprites[tempx][k*8+l]>=16&&sprites[tempx][k*8+l]<=31)||(sprites[tempx][k*8+l]>=49&&sprites[tempx][k*8+l]<=64)) {
              tempy+=pixelhealth[1];
            } else if (sprites[tempx][k*8+l]>=32&&sprites[tempx][k*8+l]<=47||(sprites[tempx][k*8+l]>=65)) {
              tempy+=pixelhealth[13];
            } else {
              tempy+=pixelhealth[sprites[tempx][k*8+l]];
            }
          }
        }
        healthmap[i*sizex+j]=tempy;
        damagemap[i*sizex+j]=tempy;

        tempx=round(ship2[i*sizex+j]);

        tempy=5;
        //for (int k = 0; k<8; k++) {
        //  for (int l = 0; l<8; l++) {
        //  if (sprites2[tempx][k*8+l]==1) {
        //    tempy+=10;
        //  } else if (sprites2[tempx][k*8+l]==13) {
        //    tempy+=50;
        //  }
        //  }
        //}
        for (int k = 0; k<8; k++) {
          for (int l = 0; l<8; l++) {
            if ((sprites2[tempx][k*8+l]>=16&&sprites2[tempx][k*8+l]<=31)||(sprites2[tempx][k*8+l]>=48&&sprites2[tempx][k*8+l]<=63)) {
              tempy+=pixelhealth[1];
            } else if ((sprites2[tempx][k*8+l]>=31&&sprites2[tempx][k*8+l]<=47)||(sprites2[tempx][k*8+l]>=64)) {
              tempy+=pixelhealth[13];
            } else {
              tempy+=pixelhealth[sprites2[tempx][k*8+l]];
            }
            //tempy+=pixelhealth[sprites2[tempx][k*8+l]];
          }
        }
        healthmap2[i*sizex+j]=tempy;
        damagemap2[i*sizex+j]=tempy;
      }
    }

    //animationtime++;
    //fill(200, 200, 200);
    //quad(0, height*0.9, 0, height*0.8, width*0.9* min(animationtime/10, 1, -animationtime/10+5), height*0.8, width*0.8* min(animationtime/10, 1, -animationtime/10+5), height*0.9);
    scene=lastscene;
  }
  if (scene==3) {//map
    //brings up pause menu when the player presses escape
    if (keyPressed&&escape) {
      paused=true;
      scene2=1;
      escape=false;
    }


    enemylvl=0;

    strokeWeight(1);
    px=50;
    fill(255, 155, 0);
    //creates new galaxy if the sun is pressed
    currentid=1;
    if (button2(zoomx(width/2, zoomx, zoomamount), zoomx(height/2, zoomy, zoomamount), 50*zoomamount, "Warp to next solar system")) {

      lastscene=14;
      scene2=4;

      zoomid=currentid;
      zoomamount=1;
    }
    if (zoomid==currentid) {
      zoomx=width/2;
      zoomy=height/2;
    }
    
    objectnumb=-1;
    randomSeed(galaxy+objectnumb);
    while (px<400) {
      if (random(1)<0.2) {
        objectnumb++;
        randomSeed(galaxy+objectnumb);
        //calculates position of object
        px=min(px+abs(randomGaussian()*50)+50, 450);
        fill(0, 255, 0, 255);
        pd=((float)millis()/100000*((500-px)*(500-px)/5000))+random(10);
        noFill();
        stroke(255, 255, 255);
        strokeWeight(1);
        if (!visited[objectnumb]) {
          circle(zoomx(width/2, zoomx, zoomamount), zoomx(height/2, zoomy, zoomamount), px*2*zoomamount);
        }
        tempy=floor(random(5));
        py=px*cos(pd);
        //randomly chooses a type of object
        if (tempy==0) {//planet
          fill(0, 255, 0);
          strokeWeight(2);
          stroke(255, 255, 255);
          //if (visited[objectnumb]) {
          //  stroke(100, 100, 100);
          //}
          currentid++;
          if (button2(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), (px/50+5+random(10))*zoomamount, "Planet")) {
            if (planets) {
              setplanet();
              for (int i = 0; i<drones.length; i++) {

                drones[i][0]=planetx;
                drones[i][1]=planety;
                drones[i][3]=planetx;
                drones[i][4]=planety;

                drones[i][2]=i*100;
                drones[i][5]=0;
                drones[i][6]=0;
              }
              maxdrones=drones.length;
              lastscene=8;

              //zoomx=px*sin(pd)+width/2;
              //zoomy=py+width/2;
              zoomid=currentid;
              zoomamount=1;
              scene2=4;
              //visited[objectnumb]=true;
              //px=500;
            }
          }
          if (zoomid==currentid) {
            zoomx=px*sin(pd)+width/2;
            zoomy=py+height/2;
          }
          //creates a second object orbiting the planet
          if (random(500)<px) {
            objectnumb++;
            randomSeed(galaxy+objectnumb);
            px2=random(25)+25;
            pd2=((float)millis()/1000)+random(10);
            stroke(255, 255, 255, 150);
            noFill();
            strokeWeight(1);
            if (!visited[objectnumb]) {
              circle(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), px2*2*zoomamount);
            }
            noStroke();
            if (floor(random(0, 3))==0) {//planet
              fill(0, 255, 0);
              strokeWeight(2);
              stroke(255, 255, 255);
              //if (visited[objectnumb]) {
              //  stroke(100, 100, 100);
              //}
              currentid++;
              if (button2(zoomx(px2*sin(pd2)+px*sin(pd)+width/2, zoomx, zoomamount), zoomx(px2*cos(pd2)+py+height/2, zoomy, zoomamount), (8+random(4))*zoomamount, "Planet")) {
                if (planets) {
                  setplanet();
                  for (int i = 0; i<drones.length; i++) {

                    drones[i][0]=planetx;
                    drones[i][1]=planety;
                    drones[i][3]=planetx;
                    drones[i][4]=planety;

                    drones[i][2]=i*100;
                    drones[i][5]=0;
                    drones[i][6]=0;
                  }
                  maxdrones=drones.length;
                  lastscene=8;
                  //zoomx=px2*sin(pd2)+px*sin(pd)+width/2;
                  //zoomy=px2*cos(pd2)+py+width/2;
                  zoomid=currentid;
                  zoomamount=1;
                  scene2=4;
                  //visited[objectnumb]=true;
                  //px=500;
                }
              }
              if (zoomid==currentid) {
                zoomx=px2*sin(pd2)+px*sin(pd)+width/2;
                zoomy=px2*cos(pd2)+py+height/2;
              }
            } else if (floor(random(0, 2))==0) {//research station
              fill(0, 0, 255);
              strokeWeight(2);
              stroke(255, 255, 255);
              //if (visited[objectnumb]) {
              //  stroke(100, 100, 100);
              //}
              currentid++;
              if (button2(zoomx(px2*sin(pd2)+px*sin(pd)+width/2, zoomx, zoomamount), zoomx(px2*cos(pd2)+py+height/2, zoomy, zoomamount), (8+random(4))*zoomamount, "Research Station")) {
                scene2=4;
                lastscene=7;
                //visited[objectnumb]=true;
                //px=500;
                zoomid=currentid;
                zoomamount=1;
              }
              if (zoomid==currentid) {
                zoomx=px2*sin(pd2)+px*sin(pd)+width/2;
                zoomy=px2*cos(pd2)+py+height/2;
              }
            } else {//enemy
              tempx=floor(random(3));
              fill(355-tempx*100, 100-tempx*100, 100-tempx*100);
              strokeWeight(2);
              stroke(255, 255, 255);
              //if (visited[objectnumb]) {
              //  stroke(100, 100, 100);
              //}
              currentid++;
              if (!visited[objectnumb]&&button2(zoomx(px2*sin(pd2)+px*sin(pd)+width/2, zoomx, zoomamount), zoomx(px2*cos(pd2)+py+height/2, zoomy, zoomamount), (8+random(4))*zoomamount, tooltips[tempx])) {
                currentobject=objectnumb;
                enemylvl=tempx+1;
                //visited[objectnumb]=true;
                //px=500;
                zoomid=currentid;
                zoomamount=1;
              }
              if (zoomid==currentid) {
                zoomx=px2*sin(pd2)+px*sin(pd)+width/2;
                zoomy=px2*cos(pd2)+py+height/2;
              }
            }
          }
        } else if (tempy==1) {//research tree
          fill(0, 0, 255);
          strokeWeight(2);
          stroke(255, 255, 255);
          //if (visited[objectnumb]) {
          //  stroke(100, 100, 100);
          //}
          currentid++;
          if (button2(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), (px/50+5+random(10))*zoomamount, "Research Station")) {
            lastscene=7;
            //zoomx=px*sin(pd)+width/2;
            //zoomy=py+width/2;
            scene2=4;
            //visited[objectnumb]=true;
            //px=500;
            zoomid=currentid;
            zoomamount=1;
          }
          if (zoomid==currentid) {
            zoomx=px*sin(pd)+width/2;
            zoomy=py+height/2;
          }
        } else if (tempy==2) {//enemy
          strokeWeight(2);
          stroke(255, 255, 255);
          //if (visited[objectnumb]) {
          //  stroke(100, 100, 100);
          //}
          tempx=floor(random(3));
          fill(355-tempx*100, 100-tempx*100, 100-tempx*100);
          currentid++;
          if (!visited[objectnumb]&&button2(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), (px/50+5+random(10))*zoomamount, tooltips[tempx])) {
            currentobject=objectnumb;
            enemylvl=tempx+1;
            //visited[objectnumb]=true;
            //px=500;
            zoomid=currentid;
            zoomamount=1;
          }
          if (zoomid==currentid) {
            zoomx=px*sin(pd)+width/2;
            zoomy=py+height/2;
          }
        } else if (tempy==3) {//shop
          strokeWeight(2);
          stroke(255, 255, 255);
          //if (visited[objectnumb]) {
          //  stroke(100, 100, 100);
          //}
          fill(255, 255, 0);
          currentid++;
          if (button2(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), (px/50+5+random(10))*zoomamount, "Shipyard")&&shops) {
            slot1=true;
            slot2=true;
            slot3=true;
            lastscene=11;
            //zoomx=px*sin(pd)+width/2;
            //zoomy=py+width/2;
            scene2=4;
            //visited[objectnumb]=true;
            //px=500;
            zoomid=currentid;
            zoomamount=1;
          }
          if (zoomid==currentid) {
            zoomx=px*sin(pd)+width/2;
            zoomy=py+height/2;
          }
        } else {
          strokeWeight(2);
          stroke(255, 255, 255);
          //if (visited[objectnumb]) {
          //  stroke(100, 100, 100);
          //}

          fill(0, 0, 0);
          currentid++;
          if (!visited[objectnumb]&&button2(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height/2, zoomy, zoomamount), (px/25+5+random(10))*zoomamount, tooltips[3])) {
            currentobject=objectnumb;
            enemylvl=1;

            if (defeatedbosses>=9) {
              boss=floor(random(9)+1);
            }
            boss=defeatedbosses+1;

            if (boss<=8) {
              for (int i = 0; i<bosses[boss-1].length; i++) {
                ship2[i]=bosses[boss-1][i];
              }
            }
            //visited[objectnumb]=true;
            //px=500;
            zoomid=currentid;
            zoomamount=1;
          }
          if (zoomid==currentid) {
            zoomx=px*sin(pd)+width/2;
            zoomy=py+height/2;
          }
        }
      } else {
        tempx+=random(8, 15);
      }
    }

    //calculates and starts a battle
    if (enemylvl!=0) {
      dronedamage=5;
      enemydmg=enemylvl;
      firerate2=300;
      acceleration2=10;
      speed2=2;
      dronespeed=0.1;
  for(int i=0;i<particles4.length;i++){
  particles4[i][4]=0;
  }


      if (boss!=0) {




        //boss=9;




        if (boss!=8&&boss!=9) {
          maxdrones=20;
          for (int i = 0; i<min(drones.length, maxdrones); i++) {
            drones[i][0]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
            drones[i][1]=shipy+randomGaussian()*100;
            drones[i][2]=dronedelay*random(0.5, 1);
            drones[i][3]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
            drones[i][4]=shipy+randomGaussian()*100;
            drones[i][5]=0;
            drones[i][6]=0;
          }
        } 

        for (int i = 0; i <bosses[boss-1].length; i++) {
          ship2[i]=bosses[boss-1][i];
        }

        if (boss==8) {//max drones
          maxdrones=drones.length;
          for (int i = 0; i<drones.length; i++) {
            drones[i][0]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
            drones[i][1]=shipy+randomGaussian()*100;
            drones[i][2]=dronedelay*random(0.5, 1);
            drones[i][3]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
            drones[i][4]=shipy+randomGaussian()*100;
            drones[i][5]=0;
            drones[i][6]=0;
          }
        } else if (boss==7) {//infinite damage

          enemydmg=6400;
          //boss 3 //self healing
        } else if (boss==1) {//self healer
          enemylvl=-1;
        } else if (boss==4) {//rapid fire
          firerate2=10;
        } else if (boss==2) {//dodges
        acceleration2=10;
        speed2=50;
        } else if (boss==3) {//fires backwards
        } else if (boss==5) {//stores lasers
        firerate2=100;
        } else if (boss==6) {//damages every player part
        } else if (boss==9) {//planet spider
          dronedamage=30;
          maxdrones=50;
          dronespeed=0.1;
          shipx2=width*0.75;
          shipy2=height*0.5;
          planetx=shipx2;
          planety=shipy2;

          for (int i=0; i<legs.length; i++) {

            legs[i][0]=shipx2;
            legs[i][1]=shipy2;
            legs[i][4]=-1;
            switch(i) {
            case 0:
              legs[i][0]+=150;
              break;
            case 1:
              legs[i][0]-=150;
              break;
            case 2:
              legs[i][1]+=150;
              break;
            case 3:
              legs[i][1]-=150;
              break;
            case 4:
              legs[i][0]+=106.066017178;
              legs[i][1]+=106.066017178;
              break;
            case 5:
              legs[i][0]-=106.066017178;
              legs[i][1]+=106.066017178;
              break;
            case 6:
              legs[i][0]-=106.066017178;
              legs[i][1]-=106.066017178;
              break;
            case 7:
              legs[i][0]+=106.066017178;
              legs[i][1]-=106.066017178;
              break;
            }

            legs[i][2]=shipx2;
            legs[i][3]=shipy2;
          }







          for (int i = 0; i<drones.length; i++) {
            if (random(3)<1) {
              drones[i][0]=random(width/2, width);
              drones[i][1]=random(-500, 0);
            } else if (random(2)<1) {
              drones[i][0]=random(width, width+500);
              drones[i][1]=random(0, height);
            } else {
              drones[i][0]=random(width/2, width);
              drones[i][1]=random(height, height+500);
            }
            drones[i][2]=dronedelay*random(0.5, 1);
            drones[i][3]=shipx2+randomGaussian()*100;
            drones[i][4]=shipy2+randomGaussian()*100;
            drones[i][5]=0;
            drones[i][6]=0;
            drones[i][7]=-1;
          }
        }
        
        
      } else {
        //max drones                           easy
        //infinite damage                      easy
        //self-healer                          easy
        //rapid fire                           easy
        //dodges projectiles                   medium
        //fires backwards                      medium
        //blinds player                        easy
        //missed projectiles loop back around  medium
        //damages every player part at once    medium

        //sets up and spawns drones based on enemy lvl

        for (int i = 0; i<drones.length; i++) {
          maxdrones =floor(random(0, (enemylvl-1)*5));
          drones[i][0]=width*random(0.45, 0.5);
          drones[i][1]=height*random(0.4, 0.6);
          drones[i][2]=dronedelay*random(0.5, 1);
          drones[i][3]=width*random(0.45, 0.5);
          drones[i][4]=height*random(0.4, 0.6);
          drones[i][5]=0;
          drones[i][6]=0;
        }
      }
      timesinceshot=0;
      if (boss==9) {
        lastscene=8;
      } else {
        lastscene=0;
      }
      zoomx=px*sin(pd)+width/2;
      zoomy=py+height/2;
      scene2=4;
      randomSeed(galaxy*2+objectnumb);
      if (boss==0) {
        //chooses a random enemy design for the player to fight
        switch(enemylvl) {
        case 1:
          tempx=floor(random(shiplvl1.length));
          break;
        case 2:
          tempx=floor(random(shiplvl2.length));
          break;
        case 3:
          tempx=floor(random(shiplvl3.length));
          break;
        }
        //switches enemy ship to new design
        for (int i=0; i<ship.length; i++) {
          switch(enemylvl) {
          case 1:
            ship2[i]=shiplvl1[tempx][i];
            break;
          case 2:
            ship2[i]=shiplvl2[tempx][i];
            break;
          case 3:
            ship2[i]=shiplvl3[tempx][i];
            break;
          }
          damagemap2[i]=healthmap2[i];
        }
      }
      //System.out.println("test");
      //finds cannon components
      tempvar6=0;
      tempvar11=0;
      cannon[0][2]=0;
      cannon[1][2]=0;
      cannon[2][2]=0;
      cannon2[0][2]=0;
      cannon2[1][2]=0;
      cannon2[2][2]=0;
      cannon2[3][2]=0;
      cannon2[4][2]=0;
      cannon2[5][2]=0;
      for (int i = 0; i<sizey; i++) {
        for (int j = 0; j<sizex; j++) {

          if (tempvar6!=-1) {
            tempvar6=round(ship[i*sizey+j]);
          }
          if (tempvar11!=-1) {
            tempvar11=round(ship2[i*sizey+j]);
          }
          for (int k = 0; k<8; k++) {
            for (int l = 0; l<8; l++) {

              if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
                if (cannon[0][2]==0) {
                  cannon[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[0][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[0][3]=0;
                  } else {
                    cannon[0][3]=1;
                  }
                } else if (cannon[1][2]==0) {
                  cannon[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[1][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[1][3]=0;
                  } else {
                    cannon[1][3]=1;
                  }
                } else if (cannon[2][2]==0) {
                  cannon[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[2][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[2][3]=0;
                  } else {
                    cannon[2][3]=1;
                  }
                } else {
                  scene2=3;
                  message="Too many emitters (3 MAX)";
                  tempvar6=-1;
                }
              }
              if (tempvar11!=-1&&(sprites2[tempvar11][k*8+l]==6||sprites2[tempvar11][k*8+l]==15)) {
                if (cannon2[0][2]==0) {
                  cannon2[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[0][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[0][3]=0;
                  } else {
                    cannon2[0][3]=1;
                  }
                } else if (cannon2[1][2]==0) {
                  cannon2[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[1][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[1][3]=0;
                  } else {
                    cannon2[1][3]=1;
                  }
                } else if (cannon2[2][2]==0) {
                  cannon2[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[2][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[2][3]=0;
                  } else {
                    cannon2[2][3]=1;
                  }
                } else if (cannon2[3][2]==0) {
                  cannon2[3][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[3][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[3][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[3][3]=0;
                  } else {
                    cannon2[3][3]=1;
                  }
                } else if (cannon2[4][2]==0) {
                  cannon2[4][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[4][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[4][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[4][3]=0;
                  } else {
                    cannon2[4][3]=1;
                  }
                } else if (cannon2[5][2]==0) {
                  cannon2[5][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[5][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[5][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[5][3]=0;
                  } else {
                    cannon2[5][3]=1;
                  }
                } else {
                  tempvar11=-1;
                }
              }
            }
          }
        }
      }
    }
  }
  if (scene2==5) {

    galaxy=floor(random(-100000, 100000));
    drawbackground();
    for (int i = 0; i<visited.length; i++) {
      visited[i]=false;
    }
    scene2=4;
    lastscene=3;
    scene=3;
  }

  //"Ship Designer" button
  if (scene==3&&scene2==0&&button(zoomx(width-165, zoomx, zoomamount), zoomx(height-40, zoomx, zoomamount), 300*zoomamount, 50*zoomamount, "Ship Designer")) {
    delay=0;
    money+=shipcost;
    scene=1;
  }

  if (scene==4) {//main menu
    menutime++;
    if (lastscene==15||(animationtime>height*0.125&&animationtime<height*0.25)) {
      animationtime+=animationvel*height/1000;
      if (animationtime>=height*0.125&&animationvel>0) {

        animationvel--;
      } else {
        animationvel++;
      }
      if (animationtime>=height*0.25) {
        lastscene=14;
      }
    } else if (lastscene==14&&animationtime>=height*0.25) {
      animationvel++;
    }
    //Text
    textSize(140*zoomamount*resize);
    //fill(0);
    
    //text("ASTR  NENT", zoomx(width/2,zoomx,zoomamount)-textWidth("ASTR  NENT")/2+13, zoomx(height*0.301+animationtime,zoomy,zoomamount)-1);
    //text("ASTR  NENT", zoomx(width/2,zoomx,zoomamount)-textWidth("ASTR  NENT")/2+11, zoomx(height*0.301+animationtime,zoomy,zoomamount)+1);
    //text("ASTR  NENT", zoomx(width/2,zoomx,zoomamount)-textWidth("ASTR  NENT")/2+13, zoomx(height*0.301+animationtime,zoomy,zoomamount)+1);
    //text("ASTR  NENT", zoomx(width/2,zoomx,zoomamount)-textWidth("ASTR  NENT")/2+11, zoomx(height*0.301+animationtime,zoomy,zoomamount)-1);
    fill(255, 255, 255, 255);        //416.44824
    textAlign(LEFT, CENTER);
    text("ASTR  NENT", zoomx(width/2, zoomx, zoomamount)-textWidth("ASTR  NENT")/2+12*resize, zoomx(height*0.25+animationtime, zoomy, zoomamount)-15*resize);
    textAlign(LEFT);

    //Logo
    noStroke();
    textSize(140*resize);
    fill(255, 155, 0);
    circle(zoomx(width/2, zoomx, zoomamount), zoomx(height*0.25+animationtime, zoomy, zoomamount), 100*zoomamount*resize);
    fill(0, 0, 255, 150);

    //planet
    px=250;
    //px=200*resize;
    pd=((float)millis()/100000*((300)*(300)/5000))-PI/2;
    noFill();
    stroke(150, 150, 150);
    strokeWeight(5*resize);
    py=px*cos(pd);
    fill(150, 150, 150, 255);
    noStroke();
    fill(0, 255, 0);
    circle(zoomx(px*sin(pd)+width/2, zoomx, zoomamount), zoomx(py+height*0.25+animationtime, zoomy, zoomamount), 40*zoomamount*resize);
    //moon
    px2=75;
    //px2=50*resize;
    pd2=((float)millis()/100000*((700)*(700)/5000));
    noFill();
    stroke(150, 150, 150);
    strokeWeight(2*resize);
    py2=px2*cos(pd2);
    fill(150, 150, 150, 255);
    noStroke();
    fill(150, 125, 100);
    circle(zoomx(px2*sin(pd2)+width/2+px*sin(pd), zoomx, zoomamount), zoomx(py+py2+height*0.25+animationtime, zoomy, zoomamount), 15*zoomamount*resize);
    //title

    //play button
    if (button(zoomx(width/2, zoomx, zoomamount), zoomx(height*0.6+animationtime*3, zoomy, zoomamount), width*0.75*zoomamount, height*0.1*zoomamount, "Play")) {
      animationtime=0;
      zoomx=width/2;
      zoomy=height/2;
      zoomamount=1;
      scene2=4;
      lastscene=15;
    } 

    if (button(zoomx(width/2, zoomx, zoomamount), zoomx(height*0.72+animationtime*3, zoomy, zoomamount), width*0.75*zoomamount, height*0.1*zoomamount, "Exit")) {
      exit();
    }
  }
  if (scene==10) {//defeat screen
    boss=0;
    textSize(200*resize);
    text("DEFEAT", width/2-textWidth("DEFEAT")/2, height*0.35);
    if (button(width/2, height*0.7, 500*resize, 120*resize, "Continue")) {
      scene2=4;
      scene=-1;
      lastscene=3;
    }
  } else if (scene==9) {//victory screen
    //System.out.println(objectnumb);
    visited[currentobject]=true;
    boss=0;
    textSize(200*resize);
    text("Victory!", width/2-textWidth("Victory!")/2, height*0.35);
    fill(200, 200, 0);
    textSize(50*resize);
    //credits gained are equal to enemylvl^2*100+100
    //lvl 1 = 200
    //lvl 2 = 500
    //lvl 3 = 1000
    if (boss!=0) {
      text("Credits Gained:"+(5000), width/2-textWidth("Credits Gained:"+(500))/2, height/2);
      if (button(500, 700, 600, 90, "Claim Rewards")) {
        money+=5000;
        scene=-1;
        scene2=4;
        lastscene=3;
      }
    } else {
      text("Credits Gained:"+(enemydmg*enemydmg*100+100), width/2-textWidth("Credits Gained:"+(enemydmg*enemydmg*100+100))/2, height/2);
      if (button(width/2, height*0.7, 600*resize, 90*resize, "Claim Rewards")) {
        money+=enemydmg*enemydmg*100+100;

        scene=-1;
        scene2=4;
        lastscene=3;
      }
    }
  } else if (scene==11) {//shop
    if (keyPressed&&escape) {
      scene2=1;
      paused=true;
      escape=false;
    }
    if (keyPressed&&key==keysindex[17]) {
      lastscene=3;
      scene2=4;
      scene=3;
    }
    randomSeed(galaxy);

    tempaction=ceil(random(ships.length-1));
    shipcost2=0;
    for (int i = 0; i<sizey; i++) {
      for (int j = 0; j<sizex; j++) {
        shipcost2+=cost[round(ships[tempaction][i*sizey+j])];
      }
    }
    if (slot1&&stock>=1&&button4(width/2, height*0.7, ships[tempaction], shipcost2)) {
      money+=shipcost;
      money-=shipcost2;
      slot1=false;
      for (int i = 0; i<ships[tempaction].length; i++) {
        ship[i]=ships[tempaction][i];
      }
      shipcost=0;
      tempvar6=0;
      tempvar11=0;
      cannon[0][2]=0;
      cannon[1][2]=0;
      cannon[2][2]=0;
      cannon2[0][2]=0;
      cannon2[1][2]=0;
      cannon2[2][2]=0;
      cannon2[3][2]=0;
      cannon2[4][2]=0;
      cannon2[5][2]=0;
      for (int i = 0; i<sizey; i++) {
        for (int j = 0; j<sizex; j++) {

          if (tempvar6!=-1) {
            tempvar6=round(ship[i*sizey+j]);
          }
          if (tempvar11!=-1) {
            tempvar11=round(ship2[i*sizey+j]);
          }
          shipcost+=cost[round(ship[i*sizey+j])];
          for (int k = 0; k<8; k++) {
            for (int l = 0; l<8; l++) {

              if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
                if (cannon[0][2]==0) {
                  cannon[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[0][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[0][3]=0;
                  } else {
                    cannon[0][3]=1;
                  }
                } else if (cannon[1][2]==0) {
                  cannon[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[1][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[1][3]=0;
                  } else {
                    cannon[1][3]=1;
                  }
                } else if (cannon[2][2]==0) {
                  cannon[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[2][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[2][3]=0;
                  } else {
                    cannon[2][3]=1;
                  }
                } else {
                  scene2=3;
                  message="Too many emitters (3 MAX)";
                  tempvar6=-1;
                }
              }
              if (tempvar11!=-1&&(sprites2[tempvar11][k*8+l]==6||sprites2[tempvar11][k*8+l]==15)) {
                if (cannon2[0][2]==0) {
                  cannon2[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[0][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[0][3]=0;
                  } else {
                    cannon2[0][3]=1;
                  }
                } else if (cannon2[1][2]==0) {
                  cannon2[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[1][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[1][3]=0;
                  } else {
                    cannon2[1][3]=1;
                  }
                } else if (cannon2[2][2]==0) {
                  cannon2[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[2][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[2][3]=0;
                  } else {
                    cannon2[2][3]=1;
                  }
                } else if (cannon2[3][2]==0) {
                  cannon2[3][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[3][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[3][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[3][3]=0;
                  } else {
                    cannon2[3][3]=1;
                  }
                } else if (cannon2[4][2]==0) {
                  cannon2[4][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[4][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[4][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[4][3]=0;
                  } else {
                    cannon2[4][3]=1;
                  }
                } else if (cannon2[5][2]==0) {
                  cannon2[5][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[5][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[5][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[5][3]=0;
                  } else {
                    cannon2[5][3]=1;
                  }
                } else {
                  tempvar11=-1;
                }
              }
            }
          }
        }
      }
    }

    tempaction=ceil(random(ships.length-1));
    shipcost2=0;
    for (int i = 0; i<sizey; i++) {
      for (int j = 0; j<sizex; j++) {
        shipcost2+=cost[round(ships[tempaction][i*sizey+j])];
      }
    }
    if (slot2&&stock>=2&&button4(width*0.25, height*0.7, ships[tempaction], shipcost2)) {
      money+=shipcost;
      money-=shipcost2;
      slot2=false;
      for (int i = 0; i<ships[tempaction].length; i++) {
        ship[i]=ships[tempaction][i];
      }
      shipcost=0;
      tempvar6=0;
      tempvar11=0;
      cannon[0][2]=0;
      cannon[1][2]=0;
      cannon[2][2]=0;
      cannon2[0][2]=0;
      cannon2[1][2]=0;
      cannon2[2][2]=0;
      cannon2[3][2]=0;
      cannon2[4][2]=0;
      cannon2[5][2]=0;
      for (int i = 0; i<sizey; i++) {
        for (int j = 0; j<sizex; j++) {
          if (tempvar6!=-1) {
            tempvar6=round(ship[i*sizey+j]);
          }
          if (tempvar11!=-1) {
            tempvar11=round(ship2[i*sizey+j]);
          }
          shipcost+=cost[round(ship[i*sizey+j])];
          for (int k = 0; k<8; k++) {
            for (int l = 0; l<8; l++) {

              if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
                if (cannon[0][2]==0) {
                  cannon[0][0]=j+(float)l/8+scale/8/8;
                  cannon[0][1]=i+(float)k/8+scale/8/8;
                  cannon[0][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[0][3]=0;
                  } else {
                    cannon[0][3]=1;
                  }
                } else if (cannon[1][2]==0) {
                  cannon[1][0]=j+(float)l/8+scale/8/8;
                  cannon[1][1]=i+(float)k/8+scale/8/8;
                  cannon[1][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[1][3]=0;
                  } else {
                    cannon[1][3]=1;
                  }
                } else if (cannon[2][2]==0) {
                  cannon[2][0]=j+(float)l/8+scale/8/8;
                  cannon[2][1]=i+(float)k/8+scale/8/8;
                  cannon[2][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[2][3]=0;
                  } else {
                    cannon[2][3]=1;
                  }
                } else {
                  scene2=3;
                  message="Too many emitters (3 MAX)";
                  tempvar6=-1;
                }
              }
              if (tempvar11!=-1&&(sprites2[tempvar11][k*8+l]==6||sprites2[tempvar11][k*8+l]==15)) {
                if (cannon2[0][2]==0) {
                  cannon2[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[0][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[0][3]=0;
                  } else {
                    cannon2[0][3]=1;
                  }
                } else if (cannon2[1][2]==0) {
                  cannon2[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[1][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[1][3]=0;
                  } else {
                    cannon2[1][3]=1;
                  }
                } else if (cannon2[2][2]==0) {
                  cannon2[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[2][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[2][3]=0;
                  } else {
                    cannon2[2][3]=1;
                  }
                } else if (cannon2[3][2]==0) {
                  cannon2[3][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[3][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[3][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[3][3]=0;
                  } else {
                    cannon2[3][3]=1;
                  }
                } else if (cannon2[4][2]==0) {
                  cannon2[4][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[4][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[4][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[4][3]=0;
                  } else {
                    cannon2[4][3]=1;
                  }
                } else if (cannon2[5][2]==0) {
                  cannon2[5][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[5][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[5][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[5][3]=0;
                  } else {
                    cannon2[5][3]=1;
                  }
                } else {
                  tempvar11=-1;
                }
              }
            }
          }
        }
      }
    }
    tempaction=ceil(random(ships.length-1));
    shipcost2=0;
    for (int i = 0; i<sizey; i++) {
      for (int j = 0; j<sizex; j++) {
        shipcost2+=cost[round(ships[tempaction][i*sizey+j])];
      }
    }
    if (slot3&&stock>=3&&button4(width*0.75, height*0.7, ships[tempaction], shipcost2)) {
      money+=shipcost;
      money-=shipcost2;
      slot3=false;
      for (int i = 0; i<ships[tempaction].length; i++) {
        ship[i]=ships[tempaction][i];
      }
      shipcost=0;
      tempvar6=0;
      tempvar11=0;
      cannon[0][2]=0;
      cannon[1][2]=0;
      cannon[2][2]=0;
      cannon2[0][2]=0;
      cannon2[1][2]=0;
      cannon2[2][2]=0;
      cannon2[3][2]=0;
      cannon2[4][2]=0;
      cannon2[5][2]=0;
      for (int i = 0; i<sizey; i++) {
        for (int j = 0; j<sizex; j++) {
          if (tempvar6!=-1) {
            tempvar6=round(ship[i*sizey+j]);
          }
          if (tempvar11!=-1) {
            tempvar11=round(ship2[i*sizey+j]);
          }
          shipcost+=cost[round(ship[i*sizey+j])];
          for (int k = 0; k<8; k++) {
            for (int l = 0; l<8; l++) {
              if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
                if (cannon[0][2]==0) {
                  cannon[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[0][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[0][3]=0;
                  } else {
                    cannon[0][3]=1;
                  }
                } else if (cannon[1][2]==0) {
                  cannon[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[1][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[1][3]=0;
                  } else {
                    cannon[1][3]=1;
                  }
                } else if (cannon[2][2]==0) {
                  cannon[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[2][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[2][3]=0;
                  } else {
                    cannon[2][3]=1;
                  }
                } else {
                  scene2=3;
                  message="Too many emitters (3 MAX)";
                  tempvar6=-1;
                }
              }
              if (tempvar11!=-1&&(sprites2[tempvar11][k*8+l]==6||sprites2[tempvar11][k*8+l]==15)) {
                if (cannon2[0][2]==0) {
                  cannon2[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[0][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[0][3]=0;
                  } else {
                    cannon2[0][3]=1;
                  }
                } else if (cannon2[1][2]==0) {
                  cannon2[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[1][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[1][3]=0;
                  } else {
                    cannon2[1][3]=1;
                  }
                } else if (cannon2[2][2]==0) {
                  cannon2[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[2][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[2][3]=0;
                  } else {
                    cannon2[2][3]=1;
                  }
                } else if (cannon2[3][2]==0) {
                  cannon2[3][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[3][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[3][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[3][3]=0;
                  } else {
                    cannon2[3][3]=1;
                  }
                } else if (cannon2[4][2]==0) {
                  cannon2[4][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[4][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[4][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[4][3]=0;
                  } else {
                    cannon2[4][3]=1;
                  }
                } else if (cannon2[5][2]==0) {
                  cannon2[5][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon2[5][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon2[5][2]=1;
                  if (sprites2[tempvar11][k*8+l]==6) {
                    cannon2[5][3]=0;
                  } else {
                    cannon2[5][3]=1;
                  }
                } else {
                  tempvar11=-1;
                }
              }
            }
          }
        }
      }
    }


    //stop
  }





  textSize(10);
  noStroke();
  fill(255, 255, 255);
  if (debug) {
    text("Number of Projectiles: "+projectilesnumb, 10, height-80);
    text("Galaxy Seed: "+galaxy, 10, height-90);
  }



  if (scene==0||scene==8) {//planet or enemy
    //stroke(255, 255, 255);
    //line(width/2, 0, width/2, height);
    noStroke();
    if (scene==8&&boss!=9) {
      shipx2=-1000;
      shipy2=-1000;
    } else if (numb%30==1) {
      //determines if the enemy ship has been destroyed and switches to victory screen
      tempvar7=0;


      if(boss==9||findpart3(0, damagemap2)[0]!=-1||findpart3(1, damagemap2)[0]!=-1||findpart3(2, damagemap2)[0]!=-1||findpart3(3, damagemap2)[0]!=-1||findpart3(4, damagemap2)[0]!=-1||findpart3(5, damagemap2)[0]!=-1){
        if (tempvar7==1) {
          tempvar7=3;
        } else {
          tempvar7=2;
        }
      }
      for (int i = 0; i<damagemap.length; i++) {
        //if (damagemap2[i]>0&&((i==floor((cannon2[0][0]+cannon2[0][1]*48)/8))||(i==floor((cannon2[1][0]+cannon2[1][1]*48)/8))||(i==floor((cannon2[2][0]+cannon2[2][1]*48)/8))||(i==floor((cannon2[3][0]+cannon2[3][1]*48)/8))||(i==floor((cannon2[4][0]+cannon2[4][1]*48)/8))||(i==floor((cannon2[5][0]+cannon2[5][1]*48)/8)))&&(tempvar7==1||tempvar7==0)) {//ship2 alive
        //
        //if (tempvar7==1) {
        //  tempvar7=3;
        //} else {
        //  tempvar7=2;
        //}
        //} 
        if ((tempvar7==2||tempvar7==0)&&(damagemap[i]>0&&healthmap[i]>10)) {//ship1 alive
          if (tempvar7==2) {
            tempvar7=3;
          } else {
            tempvar7=1;
          }
        }
      }
      if (tempvar7==1||timesinceshot>300) {//ship2 dead
        //win
        //System.out.println(timesinceshot);
        if (boss!=0) {
          defeatedbosses++;
        }
        scene=9;
      } else if (tempvar7==0||tempvar7==2) {//ship1 dead
        //lose
        scene=10;
      }
    }
    if (keyPressed&&escape) {
      scene2=1;
      paused=true;
      escape=false;
    }
    
    if (keyPressed&&key==keysindex[17]) {
      if (scene==8) {//planet
        //System.out.println("test");
        
        scene=-1;
        scene2=4;
        lastscene=3;
      } else if (scene==0) {
        boss=0;
        scene=-1;
        scene2=4;
        lastscene=3;
      } else {
        scene=-1;
        scene2=4;
        lastscene=3;
      }
    }

    if (!paused) {
      if (scene==0) {
        //4 5 6 7 up left down right
        keys[4]=false;
        keys[6]=false;
        keys[7]=false;
        dontmove=false;
        if (boss==2) {//dodging AI
        keys[9]=true;
          keys[5]=true;
          for (int i = 0; i<projectiles.length; i++) {
            if (projectiles[i][2]==1) {
              avoid(projectiles[i][0], projectiles[i][1]);
            }
          }
          if(shipx2<width*0.7&&keys[5]){
          keys[5]=false;
          }
          if (!dontmove&&keys[4]==keys[6]) {
            if (shipy<shipy2+-5) {
              keys[4]=true;
              keys[6]=false;
            } else if(shipy>shipy2+5){
              keys[6]=true;
              keys[4]=false;
            } else{
            shipy2=shipy;
            }
          }
          //System.out.println(keys[4]+" "+keys[5]+" "+keys[6]+" "+keys[7]);
          if (debug) {
            fill(255, 0, 0, 100);
            rect(shipx2-200, shipy2-60, 120, 80);
            fill(255, 255, 0, 100);
            rect(shipx2-260, shipy2-80, 190, 60);
            fill(0, 255, 0, 100);
            rect(shipx2-260, shipy2-20, 190, 60);
            fill(0, 0, 255, 100);
            rect(shipx2-270, shipy2-100, 210, 160);
          }
        } else {//simple AI

        keys[5]=false;
          timesinceshot++;
          if (shipy2>1+targety) {
            keys[4]=true;
          } else {
            keys[4]=false;
          }
          if (shipy2<-1+targety) {
            keys[6]=true;
          } else {
            keys[6]=false;
          }
          if (shipx2>1+targetx) {
            keys[5]=true;
          } else {
            keys[5]=false;
          }
          if (shipx2<-1+targetx) {
            keys[7]=true;
          } else {
            keys[7]=false;
          }
          keys[9]=true;
        }
      } else {
        keys[9]=false;
      }
      //enemy AI
      randomSeed(round(numb/100));
      if (numb%100>round(random(1, 99))) {
        targetx=random(width*0.5+150, width-150);
        targety=min(max(random(-150, 150)+shipy, 150), height-150);
      }
      //prevents ships from moving outside the boundary of the game
      if (shipx>width/2-100+shipr*40) {
        shipx=width/2-100+shipr*40;
        xvel=0;
        keys[3]=false;
        keys2[3]=false;
        //} else if (shipx>width-100) {
        //xvel=0;
        //shipx=width-100;
        //keys[3]=false;
        //keys2[3]=false;
      }
      if (shipx<140-shipl*40) {
        xvel=0;
        shipx=140-shipl*40;
        keys[1]=false;
        keys2[1]=false;
      }
      if (scene==0&&shipx2<width/2+140) {
        xvel2=0;
        shipx2=width/2+140;
        keys[6]=false;
        keys2[6]=false;
      }
      if (scene==0&&shipx2>width-100) {
        xvel2=0;
        shipx2=width-100;
        keys[4]=false;
        keys2[4]=false;
      }
      if (shipy<140-shipu*40) {
        yvel=0;
        shipy=140-shipu*40;
        keys[0]=false;
        keys2[0]=false;
      }
      if (shipy>height-100+shipd*40) {
        yvel=0;
        shipy=height-100+shipd*40;
        keys[2]=false;
        keys2[2]=false;
      }
      if (scene==0&&shipy2<140) {
        yvel2=0;
        shipy2=140;
        keys[4]=false;
        keys2[4]=false;
      }
      if (scene==0&&shipy2>height-100) {
        yvel2=0;
        shipy2=height-100;
        keys[6]=false;
        keys2[6]=false;
      }
      if (!keys[0]&&!keys[2]) {
        if (abs(yvel)<speed/acceleration) {
          yvel=0;
        } else if (yvel>0) {
          yvel-=speed/acceleration;
        } else if (yvel<0) {
          yvel+=speed/acceleration;
        }
      }
      if (!keys[1]&&!keys[3]) {
        if (abs(xvel)<speed/acceleration) {
          xvel=0;
        } else if (xvel>0) {
          xvel-=speed/acceleration;
        } else if (xvel<0) {
          xvel+=speed/acceleration;
        }
      }
      if (!keys[4]&&!keys[6]) {
        if (abs(yvel2)<speed2/acceleration2) {
          yvel2=0;
        } else if (yvel2>0) {
          yvel2-=speed2/acceleration2;
        } else if (yvel<0) {
          yvel2+=speed2/acceleration2;
        }
      }
      if (!keys[5]&&!keys[7]) {
        if (abs(xvel2)<speed2/acceleration2) {
          xvel2=0;
        } else if (xvel2>0) {
          xvel2-=speed2/acceleration2;
        } else if (xvel2<0) {
          xvel2+=speed2/acceleration2;
        }
      }
      //moves ships based on inputs
      if (keys[0]&&yvel>-speed) {
        yvel-=speed/acceleration;
      }
      if (keys[1]&&xvel>-speed) {
        xvel-=speed/acceleration;
      }
      if (keys[2]&&yvel<speed) {
        yvel+=speed/acceleration;
      }
      if (keys[3]&&xvel<speed) {
        xvel+=speed/acceleration;
      }
      if (scene==0&&keys[4]&&yvel2>-speed) {
        yvel2-=speed2/acceleration2;
      }
      if (scene==0&&keys[5]&&xvel2>-speed) {
        xvel2-=speed2/acceleration2;
      }
      if (scene==0&&keys[6]&&yvel2<speed) {
        yvel2+=speed2/acceleration2;
      }
      if (scene==0&&keys[7]&&xvel2<speed) {
        xvel2+=speed2/acceleration2;
      }
      

      shipx+=xvel;
      shipy+=yvel;
      shipx2+=xvel2;
      shipy2+=yvel2;

      nextdelay=0;
      delay-=MPF;
      nextdelay2=0;
      delay2-=MPF;
      skip=0;
    }
    drawship(shipx, shipy, 5, 6, ship, damagemap, doors, healthmap, true, true);
    if (scene!=8) {
      drawship(shipx2, shipy2, 5, 6, ship2, damagemap2, 0, healthmap2, false, true);
    }
    //fires cannons
    if (keyPressed&&(keys[14]||keys[8])) {
      if (delay<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart2(0, damagemap);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel*1.9;
              projectiles[i][1]=temparray[1]-yvel*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=dmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay+=firerate/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    if (keyPressed&&(keys[10]||keys[8])) {
      if (delay<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart2(1, damagemap);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel*1.9;
              projectiles[i][1]=temparray[1]-yvel*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=dmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay+=firerate/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    if (keyPressed&&(keys[12]||keys[8])) {
      if (delay<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart2(2, damagemap);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel*1.9;
              projectiles[i][1]=temparray[1]-yvel*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=dmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay+=firerate/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(0, damagemap2);
            //temparray=findpart(shipx2, shipy2, 5, 6, ship2, 10, skip, damagemap2, 13, 15);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            if (skip<=0)break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(1, damagemap2);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(2, damagemap2);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(3, damagemap2);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(4, damagemap2);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    }
    skip=0;
    if (keys[9]) {
      if (delay2<0) {
        for (int i=0; i<projectiles.length; i++) {
          if (projectiles[i][2]==0) {
            temparray=findpart3(5, damagemap2);
            if (temparray[0]==-1&&temparray[1]==-1) {
              i=projectiles.length;
              break;
            } else {
              projectilesnumb++;
              projectiles[i][0]=temparray[0]-xvel2*1.9;
              projectiles[i][1]=temparray[1]-yvel2*1.9;
              projectiles[i][2]=2;
              projectiles[i][3]=enemydmg/fireratemodifier;
              projectiles[i][4]=0;
              nextdelay2+=firerate2/fireratemodifier;
              projectiles[i][6]=temparray[2];
              if (temparray[2]==0) {

                projectiles[i][5]=projectilespeed;
              } else {
                projectiles[i][5]=laserspeed;
              }
            }
            break;
          }
        }
      }
    } 
    delay=max(delay+nextdelay, 0);
    delay2=max(delay2+nextdelay2, 0);
    if (mousePressed&&debug) {
      for (int i=0; i<projectiles.length; i++) {
        if (projectiles[i][2]==0) {
          projectilesnumb++;
          projectiles[i][0]=mouseX;
          projectiles[i][1]=mouseY;
          projectiles[i][2]=1;
          projectiles[i][3]=dmg/fireratemodifier;
          projectiles[i][4]=0;
          projectiles[i][5]=projectilespeed;
          if (mouseButton==LEFT) {
            projectiles[i][6]=1;
          } else {
            projectiles[i][6]=0;
          }
          //wait(20);
          i=projectiles.length;
        }
      }
    }

    //switches doors on and off (the light green pixels)
    if (keyPressed&&key==keysindex[16]&&doors==4) {
      doors=1; //on(still pressed)
    } else if ((!(keyPressed&&key==keysindex[16]))&&doors==1) {
      doors=2; //on(not pressed)
    } else if (keyPressed&&key==keysindex[16]&&doors==2) {
      doors=3; //off(still pressed)
    } else if ((!(keyPressed&&key==keysindex[16]))&&doors==3) {
      doors=4; //off(not pressed)
    }

    for (int i=0; i<projectiles.length; i++) {

      if (boss==9&&round(projectiles[i][2])!=0&&projectiles[i][0]>planetx-15&&projectiles[i][0]<planetx+15&&projectiles[i][1]>planety-15&&projectiles[i][1]<planety+15) {
        bosshealth-=projectiles[i][3];
        projectiles[i][2]=0;
      }

      //moves projectiles along with the ship

      tempx=round(findpixel(projectiles[i][0], projectiles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
      tempy=round(findpixel(projectiles[i][0], projectiles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
      if (tempx!=-1&&tempx!=8) {  
        projectiles[i][1]+=yvel;
        projectiles[i][0]+=xvel;
        tempx=round(findpixel(projectiles[i][0], projectiles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
        tempy=round(findpixel(projectiles[i][0], projectiles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
      } else if (scene==0&&tempy!=-1&&tempy!=8) {
        projectiles[i][1]+=yvel2;
        projectiles[i][0]+=xvel2;
        tempx=round(findpixel(projectiles[i][0], projectiles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
        if (scene==0) {
          tempy=round(findpixel(projectiles[i][0], projectiles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
        } else {
          tempy=0;
        }
      }




      //start of laser loop
      if (projectiles[i][6]==0||projectiles[i][2]==5) {
        steps=stepspertick;
      } else if (projectiles[i][6]==1) {
        steps=laserstepspertick;
      }
      for (int laser=0; laser<steps; laser++) {

        //transforms the projectile physics to gravity oriented
        if (scene==8&&projectiles[i][2]==1&&projectiles[i][0]>width/2&&projectiles[i][6]==0) {
          projectiles[i][2]=5;
          projectiles[i][6]=projectiles[i][5];
          projectiles[i][5]=0;
        }
        if (scene==8) {
          if (projectiles[i][2]!=0) {
            planetdrawmap[0][0]=false;
            if (planetdrawmap[max(floor((projectiles[i][0]-planetx+planetsize)/zoom), 0)][max(floor((projectiles[i][1]-planety+planetsize)/zoom), 0)]) {
              update=true;
              if (projectiles[i][2]!=3) {
                planetmap[round((projectiles[i][0]-planetx+planetsize)/nodezoom/zoom)]
                  [round((projectiles[i][1]-planety+planetsize)/nodezoom/zoom)]
                  +=min(projectiles[i][3], 5);
              }
              if (projectiles[i][3]>30) {
                projectiles[i][3]-=30;
              } else {
                projectiles[i][2]=0;
                projectilesnumb--;
              }
            }
          }
        } 
        //checks if the projectiles has gone off the screen and deletes it
        if (projectiles[i][2]!=0) {
          if (!paused) {

            if (projectiles[i][2]!=5&&(projectiles[i][0]<0||projectiles[i][0]>width||projectiles[i][1]<0||projectiles[i][1]>height)) {
             if(boss==3&&projectiles[i][0]>width){
             projectiles[i][0]-=width;
             timesinceshot=0;
             } else{
              projectilesnumb--;
              projectiles[i][2]=0;
             }
            } 
            switch (round(projectiles[i][2])) {
            case 1://right
              if (scene==8&&projectiles[i][0]>width) {
                //projectiles[i][0]-=100;
                projectiles[i][0]+=projectiles[i][5]/projectiles[i][0]/width*10;
              } else {
                
                projectiles[i][0]+=projectiles[i][5];
              }
              break;
            case 2://up
              projectiles[i][1]-=projectiles[i][5];
              break;
            case 3://left
              if (projectiles[i][0]>width/2&&projectiles[i][0]-projectiles[i][5]<width/2) {
                timesinceshot=0;
              }
              projectiles[i][0]-=projectiles[i][5];
              break;
            case 4://down
              projectiles[i][1]+=projectiles[i][5];
              break;
            case 5://planetary gravity
              tempvar8=projectiles[i][0]-planetx;
              tempvar9=projectiles[i][1]-planety;
              tempvar10=sqrt((tempvar8*tempvar8)+(tempvar9*tempvar9));
              tempvar8/=tempvar10;
              tempvar9/=tempvar10;
              projectiles[i][6]-=tempvar8/5/steps;
              projectiles[i][5]-=tempvar9/5/steps;
              projectiles[i][6]*=0.998;
              projectiles[i][5]*=0.998;
              projectiles[i][0]+=projectiles[i][6];
              projectiles[i][1]+=projectiles[i][5];
              break;
            }
            //}


            //finds what pixel the projectile in currently hitting
            tempx=round(findpixel(projectiles[i][0], projectiles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
            if (scene==0) {
              tempy=round(findpixel(projectiles[i][0], projectiles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
            }
            tempaction=0;
            if ((tempx==5||tempy==5)&&projectiles[i][4]>=0) {
              projectiles[i][4]=(projectiles[i][4]+1)*-1;
            } else if (projectiles[i][4]<0&&tempx!=5&&tempy!=5) {
              projectiles[i][4]*=-1;
            }
            //determines what happens depending on what pixel is hit
            if (tempx>=16||tempy>=16) {
              tempaction=2;
            }
            if (  tempx==6||tempy==6||(tempx>=9&&tempx<=12)  ||  (tempy>=9&&tempy<=12)  ||  tempx==1  ||  tempy==1  ||  ((tempx==3||tempy==3)&&(doors==1||doors==2))  ||  ((tempx==4||tempy==4)&&(doors==3||doors==4))   ||  tempx==13||  tempy==13||  tempx==7||  tempy==7) {
              tempaction=2;
              temppart=findpartat(projectiles[i][0], projectiles[i][1], shipx, shipy, 5, ship, 6);
              if (temppart==-1&&scene==0) {
                temppart=findpartat(projectiles[i][0], projectiles[i][1], shipx2, shipy2, 5, ship2, 6);
              }
              if ((tempx==6||tempy==6||  tempx==7||  tempy==7)) {
                tempaction=1;
              }

              if (tempx==9||tempy==9) {
                tempaction=1;
                if (projectiles[i][2]==4&&projectiles[i][4]<=0) {
                  projectiles[i][2]=1;
                }
                if (projectiles[i][2]==3&&projectiles[i][4]<=0) {
                  projectiles[i][2]=2;
                }
              } else if (tempx==10||tempy==10) {
                tempaction=1;
                if (projectiles[i][2]==1&&projectiles[i][4]<=0) {
                  projectiles[i][2]=4;
                }
                if (projectiles[i][2]==2&&projectiles[i][4]<=0) {
                  projectiles[i][2]=3;
                }
              } else   if (tempx==11||tempy==11) {
                tempaction=1;
                if (projectiles[i][2]==1&&projectiles[i][4]<=0) {
                  projectiles[i][2]=2;
                }
                if (projectiles[i][2]==4&&projectiles[i][4]<=0) {
                  projectiles[i][2]=3;
                }
              } else   if (tempx==12||tempy==12) {
                tempaction=1;
                if (projectiles[i][2]==2&&projectiles[i][4]<=0) {
                  projectiles[i][2]=1;
                }
                if (projectiles[i][2]==3&&projectiles[i][4]<=0) {
                  projectiles[i][2]=4;
                }
              } else  if (projectiles[i][2]==1&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=2;
                projectiles[i][0]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==2&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=1;
                projectiles[i][1]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==3&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=4;
                projectiles[i][0]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==4&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=3;
                projectiles[i][1]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==1&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=4;
                projectiles[i][0]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==2&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=3;
                projectiles[i][1]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==3&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=2;
                projectiles[i][0]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==4&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=1;
                projectiles[i][1]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==1&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=2;
                projectiles[i][0]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==2&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=1;
                projectiles[i][1]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==3&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=4;
                projectiles[i][0]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==4&&(tempx==4||tempy==4)&&(doors==3||doors==4)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=3;
                projectiles[i][1]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==1&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=4;
                projectiles[i][0]-=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==2&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=3;
                projectiles[i][1]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==3&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=2;
                projectiles[i][0]+=projectiles[i][5];
                tempaction=1;
              } else  if (projectiles[i][2]==4&&(tempx==3||tempy==3)&&(doors==1||doors==2)) {
                if (projectiles[i][4]<=0)
                  projectiles[i][2]=1;
                projectiles[i][1]-=projectiles[i][5];
                tempaction=1;
              }

              if (tempaction==0) {
                tempaction=1;
              }
            } else if (tempx==2||tempy==2) {

              if (tempx==2) {
                projectiles[i][3]+=(damageamount/fireratemodifier)/steps;
              } else {
                projectiles[i][3]+=(0.5/fireratemodifier)/steps;
              }
            } else if (tempx==14||tempy==14) {
              projectiles[i][3]-=healamount/fireratemodifier;
            }
            if (tempx==7) {
              temparray=finddistancetogrid(projectiles[i][0], projectiles[i][1], 5, shipx, shipy);
              if (projectiles[i][2]==4||projectiles[i][2]==2) {
                projectiles[i][0]-=(projectiles[i][0]-temparray[0])/4;
              }
              if (projectiles[i][2]==1||projectiles[i][2]==3) {
                projectiles[i][1]-=(projectiles[i][1]-temparray[1])/4;
              }
            } else if (tempy==7) {
            }
            if (projectiles[i][4]>0&&tempaction>0) {
              tempaction=3;
            }
            //does the decided action
            switch(tempaction) {
              //case 0://nothing
              //break;
              //case 1://reflection
              //break;
            case 2://damage




              randomSeed(millis());
              tempx = findx(projectiles[i][0], shipx, 5);
              tempy = findx(projectiles[i][1], shipy, 5);
              if (tempx<sizex&&tempx>=0&&tempy<sizey&&tempy>=0) {
                damagemap[tempx+tempy*6]=min(damagemap[tempx+tempy*6]-projectiles[i][3]/healthmodifier,healthmap[tempx+tempy*6]*5);

                projectilesnumb--;
                //System.out.println(projectiles[i][2]);
                if (projectiles[i][6]==0&&projectiles[i][3]>0)
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    xvel+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 2://up
                    yvel-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 3://left
                    xvel-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 4://down
                    yvel+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  }
                for (int p = 0; p<particleamount*min(projectiles[i][3]/100+3, 2); p++) {
                  if (projectiles[i][3]>0) {
                    if (index>=particles.length-1)index=0;
                    particles[index][0]=projectiles[i][0];
                    particles[index][1]=projectiles[i][1];
                    //moves the projectiles back one step(to prevent particles getting stuck in the wall)
                    switch (round(projectiles[i][2])) {
                    case 1://right
                      particles[index][0]-=projectiles[i][5];
                      break;
                    case 2://up
                      particles[index][1]+=projectiles[i][5];
                      break;
                    case 3://left
                      particles[index][0]+=projectiles[i][5];
                      break;
                    case 4://down
                      particles[index][1]-=projectiles[i][5];
                      break;
                    }
                    particles[index][2]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+xvel;
                    particles[index][3]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+yvel;
                    particles[index][4]=random(particleminsize, particlemaxsize)*min(projectiles[i][3]/100+0.5, 2);
                    particles[index][5]=projectiles[i][4];
                    index++;
                  } else {
                    if (index2>=particles2.length-1)index2=0;
                    particles2[index2][0]=projectiles[i][0];
                    particles2[index2][1]=projectiles[i][1];
                    particles2[index2][2]=abs(projectiles[i][3]*3);
                    particles2[index2][3]=abs(projectiles[i][3]*3);
                    index2++;

                    break;
                  }
                }
                projectiles[i][2]=0;
                break;//dont know if needed
              }
              tempx = findx(projectiles[i][0], shipx2, 5);
              tempy = findx(projectiles[i][1], shipy2, 5);
              if (scene==0&&tempx<6&&tempx>-1&&tempy<6&&tempy>-1) {
                //damagemap2[tempx+tempy*6]-=projectiles[i][3]/healthmodifier;
              damagemap2[tempx+tempy*6]=min(damagemap2[tempx+tempy*6]-projectiles[i][3]/healthmodifier,healthmap2[tempx+tempy*6]*5);
                projectilesnumb--;
                if (projectiles[i][6]==0&&projectiles[i][3]>0)
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    xvel2+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 2://up
                    yvel2-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 3://left
                    xvel2-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 4://down
                    yvel2+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  }
                for (int p = 0; p<particleamount*min(projectiles[i][3]/100+3, 2); p++) {
                  if (projectiles[i][3]>0) {
                    if (index>=particles.length-1) {
                      index=0;
                    }
                    particles[index][0]=projectiles[i][0];
                    particles[index][1]=projectiles[i][1];
                    //moves the projectiles back one step(to prevent particles getting stuck in the wall)
                    switch (round(projectiles[i][2])) {
                    case 1://right
                      particles[index][0]-=projectiles[i][5];
                      break;
                    case 2://up
                      particles[index][1]+=projectiles[i][5];
                      break;
                    case 3://left
                      particles[index][0]+=projectiles[i][5];
                      break;
                    case 4://down
                      particles[index][1]-=projectiles[i][5];
                      break;
                    }
                    particles[index][2]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+xvel2;
                    particles[index][3]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+yvel2;
                    particles[index][4]=random(particleminsize, particlemaxsize)*min(projectiles[i][3]/100+0.5, 2);
                    particles[index][5]=projectiles[i][4];
                    index++;
                  } else {
                    if (index2>=particles2.length-1)index2=0;
                    particles2[index2][0]=projectiles[i][0];
                    particles2[index2][1]=projectiles[i][1];
                    particles2[index2][2]=abs(projectiles[i][3]*3);
                    particles2[index2][3]=abs(projectiles[i][3]*3);
                    index2++;
                    break;
                  }
                }
                projectiles[i][2]=0;
              }
              break;

            case 3://pierce
              tempx = findx(projectiles[i][0], shipx, 5);
              tempy = findx(projectiles[i][1], shipy, 5);
              if (tempx<6&&tempx>-1&&tempy<6&&tempy>-1) {


                temppart=min(damagemap[tempx+tempy*6], projectiles[i][3]);
                if (projectiles[i][6]==0&&projectiles[i][3]>0) {//deleted this: temppart+1>projectiles[i][3]&&    not sure if important
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    xvel+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 2://up
                    yvel-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 3://left
                    xvel-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 4://down
                    yvel+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  }
                }
                damagemap[tempx+tempy*6]=min(damagemap[tempx+tempy*6]-temppart/healthmodifier,healthmap[tempx+tempy*6]*5);
                //damagemap[tempx+tempy*6]-=temppart/healthmodifier;
                for (int p = 0; p<particleamount*min(projectiles[i][3]/100+3, 2); p++) {
                  if (index>=particles.length-1)index=0;
                  particles[index][0]=projectiles[i][0];
                  particles[index][1]=projectiles[i][1];
                  //moves the projectiles back one step(to prevent particles getting stuck in the wall)
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    particles[index][0]-=projectiles[i][5];

                    break;
                  case 2://up
                    particles[index][1]+=projectiles[i][5];
                    break;
                  case 3://left

                    particles[index][0]+=projectiles[i][5];
                    break;
                  case 4://down
                    particles[index][1]-=projectiles[i][5];
                    break;
                  }
                  particles[index][2]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+xvel;
                  particles[index][3]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+yvel;
                  particles[index][4]=random(particleminsize, particlemaxsize)*min(projectiles[i][3]/100+0.5, 2);
                  particles[index][5]=projectiles[i][4];
                  index++;
                }
                projectiles[i][3]-=temppart;
                if (projectiles[i][3]<1) {
                  projectiles[i][2]=0;
                  projectilesnumb--;

                  break;
                }
              }
              tempx = findx(projectiles[i][0], shipx2, 5);
              tempy = findx(projectiles[i][1], shipy2, 5);
              if (scene==0&&tempx<6&&tempx>-1&&tempy<6&&tempy>-1) {
                temppart=min(damagemap2[tempx+tempy*6], projectiles[i][3]);
                temppart=min(damagemap[tempx+tempy*6], projectiles[i][3]);
                if (projectiles[i][6]==0&&temppart+1>projectiles[i][3]&&projectiles[i][3]>0) {
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    xvel2+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 2://up
                    yvel2-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 3://left
                    xvel2-=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  case 4://down
                    yvel2+=min(sqrt(projectiles[i][3]/2)/knockback,5);
                    break;
                  }
                }
                for (int p = 0; p<particleamount*min(projectiles[i][3]/100+3, 2); p++) {
                  if (index>=particles.length-1)index=0;
                  particles[index][0]=projectiles[i][0];
                  particles[index][1]=projectiles[i][1];
                  //moves the projectiles back one step(to prevent particles getting stuck in the wall)
                  switch (round(projectiles[i][2])) {
                  case 1://right
                    particles[index][0]-=projectiles[i][5];

                    break;
                  case 2://up
                    particles[index][1]+=projectiles[i][5];
                    break;
                  case 3://left

                    particles[index][0]+=projectiles[i][5];
                    break;
                  case 4://down
                    particles[index][1]-=projectiles[i][5];
                    break;
                  }
                  particles[index][2]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+xvel2;
                  particles[index][3]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+yvel2;
                  particles[index][4]=random(particleminsize, particlemaxsize)*min(projectiles[i][3]/100+0.5, 2);
                  particles[index][5]=projectiles[i][4];
                  index++;
                }
                damagemap2[tempx+tempy*6]=min(damagemap2[tempx+tempy*6]-temppart/healthmodifier,healthmap2[tempx+tempy*6]*5);
                  //damagemap2[tempx+tempy*6]-=temppart/healthmodifier;
                projectiles[i][3]-=temppart;
                if (projectiles[i][3]<1) {
                  projectiles[i][2]=0;
                  projectilesnumb--;
                }
              }
              break;
            }//end of actions
          }
          //draws projectile
          if (projectiles[i][6]==0||projectiles[i][2]==5) {
            if (index3>=particles3.length) {
              index3=index3%particles3.length;
            }
            circle2(projectiles[i]);
          } else {
            if (projectiles[i][4]>0) {
              fill(255, 155, 0);
            } else {
              fill(255, 0, 0);
            }
            
            square(projectiles[i][0]-(scale/2+1), projectiles[i][1]-(scale/2+1), scale+2);
          }
        }





        //end of laser loop
      }
    }
  }

  if (scene==8||scene==0) {//planet

    //particle systems
    for (int i = 0; i<particles.length; i++) {
      if (particles[i][4]>0) {
        if (!paused) {

          tempx=round(findpixel(particles[i][0], particles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
          tempy=round(findpixel(particles[i][0], particles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
          if (tempx==1||tempx==3||tempx==4||tempx==9||tempx==10||tempx==11||tempx==12||tempx==13) {
            particles[i][0]+=particles[i][2];
            particles[i][1]+=particles[i][3];
          } else {
            particles[i][0]+=particles[i][2]*particlespeed;
            tempx=round(findpixel(particles[i][0], particles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
            tempy=round(findpixel(particles[i][0], particles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
            if (tempx==1||tempx==3||tempx==4||tempx==9||tempx==10||tempx==11||tempx==12||tempx==13) {
              particles[i][0]-=particles[i][2]*particlespeed;
              particles[i][2]*=-0.5;
            }
            particles[i][1]+=particles[i][3]*particlespeed;
            tempx=round(findpixel(particles[i][0], particles[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
            tempy=round(findpixel(particles[i][0], particles[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
            if (tempx==1||tempx==3||tempx==4||tempx==9||tempx==10||tempx==11||tempx==12||tempx==13) {
              particles[i][1]-=particles[i][3]*particlespeed;
              particles[i][3]*=-0.5;
            }
          }
          particles[i][4]-=0.2*particlespeed;
          particles[i][2]*=0.99;
          particles[i][3]*=0.99;

          for (int j = 0; j<particles3.length; j++) {
            if (particles3[j][2]<=0) {
              particles3[j][0]=particles[i][0];
              particles3[j][1]=particles[i][1];
              particles3[j][2]=particles[i][4]*particles[i][4]/2;
              particles3[j][3]=particles[i][4]*particles[i][4]/2;
              particles3[j][4]=0;
              j=particles3.length;
            }
          }
        }
        //System.out.println(particles[i][5]);
        fill(255, 255/(particles[i][4]/2), 0);



        circle(particles[i][0], particles[i][1], particles[i][4]);//circle
        //translate(particles[i][0],particles[i][1]);
        //rotate(particles[i][2]*100+particles[i][3]*50);
        //square(0, 0, particles[i][4]);//square
        //rotate(-(particles[i][2]*100+particles[i][3]*50));
        //translate(-particles[i][0],-particles[i][1]);
        //circle(particles[i][5]+20,i*5,2);
      }
    }
    if (index3>=particles3.length) {
      index3=index3%particles3.length;
    }
    breakloop=false;
    for (int i = index3; i<index3||!breakloop; i++) {
      if (i>=particles3.length) {
        i-=particles3.length;
        breakloop=true;
      }

      if (particles3[i][2]>0) {

        if (!paused) {
          //if(particles3[i][2]>100){
          //particles3[i][2]/=sqrt(particles3[i][2])*2;
          //}
          particles3[i][2]-=trailsize*(particles3[i][3]/50);

          tempx=round(findpixel(particles3[i][0], particles3[i][1], shipx, shipy, 5, ship, 6, damagemap, damagemap21, true));
          tempy=round(findpixel(particles3[i][0], particles3[i][1], shipx2, shipy2, 5, ship2, 6, damagemap2, damagemap22, false));
          if (tempx!=-1&&tempx!=8) {
            particles3[i][1]+=yvel;
            particles3[i][0]+=xvel;
          } else if (tempy!=-1&&tempy!=8) {
            particles3[i][1]+=yvel2;
            particles3[i][0]+=xvel2;
          }
        }
        switch(round(particles3[i][4])) {
        case 0:
          fill(255, 200*(particles3[i][2]/particles3[i][3]), 0, 255);
          break;
        case 1:
          fill(255, 255, 200*(particles3[i][2]/particles3[i][3]), 255);
          break;  
        case 2:
          fill(300*(1-particles3[i][2]/particles3[i][3]), 255, 300*(1-particles3[i][2]/particles3[i][3]), 255);
          break;
        }

        if (particles3[i][2]>200) {
          circle(particles3[i][0], particles3[i][1], 28.28);
        } else {
          circle(particles3[i][0], particles3[i][1], sqrt(particles3[i][2])*2);
        }
      }
    }
    //if (scene==8) {
    //  fill(0, 0, 255);
    //  for (int i = 0; i<projectiles.length; i++) {
    //    if (projectiles[i][2]!=0) {
    //      planetdrawmap[0][0]=false;
    //      if (planetdrawmap[max(floor((projectiles[i][0]-planetx+planetsize)/zoom), 0)][max(floor((projectiles[i][1]-planety+planetsize)/zoom), 0)]) {
    //        update=true;
    //        if (projectiles[i][2]!=3) {
    //          planetmap[round((projectiles[i][0]-planetx+planetsize)/nodezoom/zoom)]
    //            [round((projectiles[i][1]-planety+planetsize)/nodezoom/zoom)]
    //            +=min(projectiles[i][3], 5);
    //        }
    //        if (projectiles[i][3]>30) {
    //          projectiles[i][3]-=30;
    //        } else {
    //          projectiles[i][2]=0;
    //          projectilesnumb--;
    //        }
    //      }
    //    }
    //  }
    //}


    randomSeed(millis());
    for (int j = 0; j<maxdrones; j++) {
      if (!paused) {
        if (drones[j][0]<drones[j][3]-dronespeed) {
          drones[j][5]+=dronespeed;
        }
        if (drones[j][0]>drones[j][3]+dronespeed) {
          drones[j][5]-=dronespeed;
        }
        if (drones[j][1]<drones[j][4]-dronespeed) {
          drones[j][6]+=dronespeed;
        }
        if (drones[j][1]>drones[j][4]+dronespeed) {
          drones[j][6]-=dronespeed;
        }
        drones[j][0]+=drones[j][5];
        drones[j][1]+=drones[j][6];
        drones[j][5]*=0.98;
        drones[j][6]*=0.98;
        drones[j][2]-=dronespeed*10;
        if (boss==9&&drones[j][2]%30<1) {
          //if (boss==9&&(((sqrt((drones[j][4]-shipy2)*(drones[j][4]-shipy2)+(drones[j][3]-shipx2)*(drones[j][3]-shipx2))>250)&&drones[j][2]%30<5))) {
          drones[j][3]=random(width*0.6, width*0.9);
          drones[j][4]=min(max(shipy2+random(500)-250, height*0.2), height*0.8);
          //drones[j][2]=dronedelay*random(0.5,1);
        }

        //if ((boss!=9&&drones[j][2]<=0)) {
        //System.out.println(second());
        //drones[j][2]=dronedelay*random(0.5, 1);
        //drones[j][3]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
        //drones[j][4]=shipy+randomGaussian()*100;
        //} 

        if ((drones[j][2]<=0)&&(boss==9||scene==8||drones[j][0]<width/2)) {
          drones[j][2]=dronedelay*random(0.5, 1);
          if (random(fireratemodifier)<=1) {
            
            if(scene!=8||(scene==8&&drones[j][0]<width/2)){
            for (int i=0; i<projectiles.length; i++) {
              if (projectiles[i][2]==0) {
                // temparray=findpart(shipx2, shipy2, 5, 6, ship2, 10, skip, damagemap2);
                //  if (temparray[0]==-1&&temparray[1]==-1) {
                //  i=projectiles.length;
                //  break;
                //} else {
                //System.out.println(i);
                
                projectilesnumb++;
                projectiles[i][0]=drones[j][0];
                projectiles[i][1]=drones[j][1];
                projectiles[i][2]=3;
                projectiles[i][3]=dronedamage/fireratemodifier;

                if (random(1)>0.7) {
                  //projectiles[i][6]=0;
                  projectiles[i][4]=3;
                  projectiles[i][5]=projectilespeed*random(0.8, 1.2);
                } else {
                  //projectiles[i][6]=0;
                  projectiles[i][4]=0;
                  projectiles[i][5]=projectilespeed*random(0.8, 1.2);
                } 
                projectiles[i][6]=1;
                projectiles[i][5]=laserspeed/2;
                //}
                //}
                i=projectiles.length+1;
              }
            }
          }
          }
          //System.out.println(second());
          drones[j][2]=dronedelay*random(0.5, 1);
          drones[j][3]=min(width*random(0.45, 0.5)+randomGaussian()*10, width/2);
          drones[j][4]=shipy+randomGaussian()*100;
        }
      }
      fill(255, 255, 255);
      //circle(drones[j][0],drones[j][1],5);
      if (drones[j][0]<planetx+width/2-5||drones[j][1]<width/2-5||drones[j][1]>width/2+5) {
        if (boss!=9&&scene==8) {
          dronesize=min(1-(drones[j][0]-width/2)/(planetx-width/2),1)*dronesize2;
        //width/2 min  500 1
        //planetx max  800 0
        //
        //800-500=300      650         500      800      500
        //            (drone[j][0]-width/2)/(planetx-width/2)
      }
        if (simpledrones) {
          triangle(drones[j][0]+4*dronesize, drones[j][1]+2*dronesize, drones[j][0]+4*dronesize, drones[j][1]-2*dronesize, drones[j][0]-3*dronesize, drones[j][1]);
        } else {
          //if (drones[j][7]>=0) {
          //fill(0, 255, 0);
          //} else {
          fill(255);
          //}
          square(-dronesize+drones[j][0], -dronesize+drones[j][1], dronesize*1.7);
          triangle(drones[j][0], dronesize*1.5+drones[j][1], dronesize*1.5+drones[j][0], dronesize*1+drones[j][1], drones[j][0], drones[j][1]);
          triangle(drones[j][0], -dronesize*1.5+drones[j][1], dronesize*1.5+drones[j][0], -dronesize*1+drones[j][1], drones[j][0], drones[j][1]);
          triangle(drones[j][0], dronesize*1.5+drones[j][1], drones[j][0], -dronesize*1.5+drones[j][1], -dronesize*4+drones[j][0], drones[j][1]);
        }

        //dronesize=dronesize2;
      }
    }
  }


  if (scene==0) {
    //System.out.println(second());
    drawship(shipx, shipy, 5, 6, ship, damagemap, doors, healthmap, true, false);
    drawship(shipx2, shipy2, 5, 6, ship2, damagemap2, doors, healthmap2, false, false);
  } else if (scene==8) {
    drawship(shipx, shipy, 5, 6, ship, damagemap, doors, healthmap, true, false);
  }

  if (scene==1) {//ship editor
    if (tutorial[5]&&false) {
      paused=true;
      scene2=6;
      if (mousePressed) {
        scene2=0;
        paused=false;
        tutorial[6]=false;
      }
    }
    fill(40);

    square(width-resize*560, height*0.5-resize*240, resize*480);

    drawship(width-resize*280, height*0.5+resize*40, resize*10, 6, ship, damagemap, doors, healthmap, true, true);
    drawship(width-resize*280, height*0.5+resize*40, resize*10, 6, ship, damagemap, doors, healthmap, true, false);

    if (keyPressed&&debug&&key==','&&delay>0)delay=-1*abs(delay-1);
    if (keyPressed&&debug&&key=='.'&&delay>=0)delay=-1*abs(delay+1);
    if ((!keyPressed)&&delay<0)delay=-delay;
    if (delay>=sprites.length) {
      delay=sprites.length-1;
    }
    if (-delay>=sprites.length) {
      delay=(-sprites.length-1);
    }


    //LMB
    if (min(max(delay, 0), sprites.length-1)==delay) {
      drawsprite2(120, 370, resize*10, delay2, 0, 0, doors, 100, true, true);
      drawsprite2(120, 370, resize*10, delay2, 0, 0, doors, 100, true, false);
    }
    //RMB
    if (min(max(delay, 0), sprites.length-1)==delay) {
      drawsprite2(120, 370, resize*10, delay2, 0, 0, doors, 100, true, true);
      drawsprite2(120, 370, resize*10, delay2, 0, 0, doors, 100, true, false);
    }

    //drawsprite2((j-size/2)*scale+x, (i-size/2)*scale+y, scale/8, round(ship[(i*size+j)]), damagemap[i*6+j], (i*i+1)*(j+1)+i, doors);
    if (mousePressed&&!paused) {
      //System.out.println(findpartat(mouseX,mouseY,width/2,height/2,5,ship,6));
      //System.out.print(" "+findx(mouseX,width/2,5));
      if (findx(mouseX, width-resize*280, resize*10)>=0&&findx(mouseX, width-resize*280, resize*10)<sizex&&findx(mouseY, height*0.5+resize*40, resize*10)>=0&&findx(mouseY, height*0.5+resize*40, resize*10)<sizey) {
        if (ship[findx(mouseX, width-resize*280, resize*10)+findx(mouseY, height*0.5+resize*40, resize*10)*sizex]<64||ship[findx(mouseX, width-resize*280, resize*10)+findx(mouseY, height*0.5+resize*40, resize*10)*sizex]==73||debug) {
          if (mouseButton==LEFT) {
            ship[findx(mouseX, width-resize*280, resize*10)+findx(mouseY, height*0.5+resize*40, resize*10)*sizex]=delay2;
          } else if (mouseButton==RIGHT) {
            ship[findx(mouseX, width-resize*280, resize*10)+findx(mouseY, height*0.5+resize*40, resize*10)*sizex]=secondpart2;
          }
        }
      }
    }
    fill(255, 255, 255);
    if (delay>=0&&delay<cost.length)
      text("Cost of Part: "+cost[delay], 5, 30);
    text("Cost of Ship: "+shipcost, 5, 45);
    //if(button(width-165,height-110,300,50,"Back")){
    //scene=3;
    //}
    if (button(width-165, height-40, 300, 50, "Back")) {
      shipr=0;
      shipl=0;
      shipu=0;
      shipd=0;
      if (healthmap[0]<=5&&healthmap[1]<=5&&healthmap[2]<=5&&healthmap[3]<=5&&healthmap[4]<=5&&healthmap[5]<=5) {
        shipu=1;
        if (healthmap[6]<=5&&healthmap[7]<=5&&healthmap[8]<=5&&healthmap[9]<=5&&healthmap[10]<=5&&healthmap[11]<=5) {
          shipu=2;
          if (healthmap[12]<=5&&healthmap[13]<=5&&healthmap[14]<=5&&healthmap[15]<=5&&healthmap[16]<=5&&healthmap[17]<=5) {
            shipu=3;
            if (healthmap[18]<=5&&healthmap[19]<=5&&healthmap[20]<=5&&healthmap[21]<=5&&healthmap[22]<=5&&healthmap[23]<=5) {
              shipu=4;
              if (healthmap[24]<=5&&healthmap[25]<=5&&healthmap[26]<=5&&healthmap[27]<=5&&healthmap[28]<=5&&healthmap[29]<=5) {
                shipu=5;
                if (healthmap[30]<=5&&healthmap[31]<=5&&healthmap[32]<=5&&healthmap[33]<=5&&healthmap[34]<=5&&healthmap[35]<=5) {
                  shipu=6;
                }
              }
            }
          }
        }
      }


      if (healthmap[30]<=5&&healthmap[31]<=5&&healthmap[32]<=5&&healthmap[33]<=5&&healthmap[34]<=5&&healthmap[35]<=5) {
        shipd=1;
        if (healthmap[24]<=5&&healthmap[25]<=5&&healthmap[26]<=5&&healthmap[27]<=5&&healthmap[28]<=5&&healthmap[29]<=5) {
          shipd=2;
          if (healthmap[18]<=5&&healthmap[19]<=5&&healthmap[20]<=5&&healthmap[21]<=5&&healthmap[22]<=5&&healthmap[23]<=5) {
            shipd=3;
            if (healthmap[12]<=5&&healthmap[13]<=5&&healthmap[14]<=5&&healthmap[15]<=5&&healthmap[16]<=5&&healthmap[17]<=5) {
              shipd=4;
              if (healthmap[6]<=5&&healthmap[7]<=5&&healthmap[8]<=5&&healthmap[9]<=5&&healthmap[10]<=5&&healthmap[11]<=5) {
                shipd=5;
                if (healthmap[0]<=5&&healthmap[1]<=5&&healthmap[2]<=5&&healthmap[3]<=5&&healthmap[4]<=5&&healthmap[5]<=5) {
                  shipd=6;
                }
              }
            }
          }
        }
      }
      if (healthmap[5]<=5&&healthmap[11]<=5&&healthmap[17]<=5&&healthmap[23]<=5&&healthmap[29]<=5&&healthmap[35]<=5) {
        shipr=1;
        if (healthmap[4]<=5&&healthmap[10]<=5&&healthmap[16]<=5&&healthmap[22]<=5&&healthmap[28]<=5&&healthmap[34]<=5) {
          shipr=2;
          if (healthmap[3]<=5&&healthmap[9]<=5&&healthmap[15]<=5&&healthmap[21]<=5&&healthmap[27]<=5&&healthmap[33]<=5) {
            shipr=3;
            if (healthmap[2]<=5&&healthmap[8]<=5&&healthmap[14]<=5&&healthmap[20]<=5&&healthmap[26]<=5&&healthmap[32]<=5) {
              shipr=4;
              if (healthmap[1]<=5&&healthmap[7]<=5&&healthmap[13]<=5&&healthmap[19]<=5&&healthmap[25]<=5&&healthmap[31]<=5) {
                shipr=5;
                if (healthmap[0]<=5&&healthmap[6]<=5&&healthmap[12]<=5&&healthmap[18]<=5&&healthmap[24]<=5&&healthmap[30]<=5) {
                  shipr=6;
                }
              }
            }
          }
        }
      }


      if (healthmap[0]<=5&&healthmap[6]<=5&&healthmap[12]<=5&&healthmap[18]<=5&&healthmap[24]<=5&&healthmap[30]<=5) {
        shipl=1;
        if (healthmap[1]<=5&&healthmap[7]<=5&&healthmap[13]<=5&&healthmap[19]<=5&&healthmap[25]<=5&&healthmap[31]<=5) {
          shipl=2;
          if (healthmap[2]<=5&&healthmap[8]<=5&&healthmap[14]<=5&&healthmap[20]<=5&&healthmap[26]<=5&&healthmap[32]<=5) {
            shipl=3;
            if (healthmap[3]<=5&&healthmap[9]<=5&&healthmap[15]<=5&&healthmap[21]<=5&&healthmap[27]<=5&&healthmap[33]<=5) {
              shipl=4;
              if (healthmap[4]<=5&&healthmap[10]<=5&&healthmap[16]<=5&&healthmap[22]<=5&&healthmap[28]<=5&&healthmap[34]<=5) {
                shipl=5;
                if (healthmap[5]<=5&&healthmap[11]<=5&&healthmap[17]<=5&&healthmap[23]<=5&&healthmap[29]<=5&&healthmap[35]<=5) {
                  shipl=6;
                }
              }
            }
          }
        }
      }
      shipcost=0;
      tempvar6=0;
      tempvar11=0;
      cannon[0][2]=0;
      cannon[1][2]=0;
      cannon[2][2]=0;
      for (int i = 0; i<sizey; i++) {
        for (int j = 0; j<sizex; j++) {
          if (tempvar6!=-1) {
            tempvar6=round(ship[i*sizey+j]);
          }
          shipcost+=cost[round(ship[i*sizey+j])];


          for (int k = 0; k<8; k++) {
            for (int l = 0; l<8; l++) {
              if (tempvar6!=-1&&(sprites[tempvar6][k*8+l]==6||sprites[tempvar6][k*8+l]==15)) {
                if (cannon[0][2]==0) {
                  cannon[0][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[0][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[0][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[0][3]=0;
                  } else {
                    cannon[0][3]=1;
                  }
                } else if (cannon[1][2]==0) {
                  cannon[1][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[1][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[1][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[1][3]=0;
                  } else {
                    cannon[1][3]=1;
                  }
                } else if (cannon[2][2]==0) {
                  cannon[2][0]=j+(float)l/8+scale/8/8;//+k/8;
                  cannon[2][1]=i+(float)k/8+scale/8/8;//+l/8;
                  cannon[2][2]=1;
                  if (sprites[tempvar6][k*8+l]==6) {
                    cannon[2][3]=0;
                  } else {
                    cannon[2][3]=1;
                  }
                } else {
                  scene2=3;
                  message="Too many emitters (3 MAX)";
                  tempvar6=-1;
                }
              }
            }
          }
        }
      }
      //System.out.println(shipcost+" "+round(ship[1*sizey+1]));


      if (shipcost<=money) {
        if(scene2!=3){
        money-=shipcost;
        scene=3;
        }
      } else {
        alert="Not Enough Money To Construct Ship";
        alerttime=100;
      }
    }

    if (button(width-165, height-110, 300, 50, "Part Designer")) {
      scene=2;
    }
    //if (keyPressed&&key==']')scene=2;
  }
  if (scene==1) {//selection menu(ship-part)
    if ((currentpage2>0)&&button(80*resize, height-440*resize, 20, 20, "<")) {
      currentpage2--;
    }
    if ((debug||currentpage2<pages2)&&button(320*resize, height-440*resize, 20, 20, ">")) {
      currentpage2++;
    }
    //4x4
    // 100 200 300 400
    // 80     160 240 320 400 480      560 640 720 800 880     960
    //
    if (button3(80*resize, height-360*resize, 0+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=0+16*currentpage2;
      } else {
        secondpart2=0+16*currentpage2;
      }
    }
    if (button3(160*resize, height-360*resize, 1+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=1+16*currentpage2;
      } else {
        secondpart2=1+16*currentpage2;
      }
    }
    if (button3(240*resize, height-360*resize, 2+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=2+16*currentpage2;
      } else {
        secondpart2=2+16*currentpage2;
      }
    }
    if (button3(320*resize, height-360*resize, 3+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=3+16*currentpage2;
      } else {
        secondpart2=3+16*currentpage2;
      }
    }
    if (button3(80*resize, height-280*resize, 4+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=4+16*currentpage2;
      } else {
        secondpart2=4+16*currentpage2;
      }
    }
    if (button3(160*resize, height-280*resize, 5+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=5+16*currentpage2;
      } else {
        secondpart2=5+16*currentpage2;
      }
    }
    if (button3(240*resize, height-280*resize, 6+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=6+16*currentpage2;
      } else {
        secondpart2=6+16*currentpage2;
      }
    }
    if (button3(320*resize, height-280*resize, 7+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=7+16*currentpage2;
      } else {
        secondpart2=7+16*currentpage2;
      }
    }
    if (button3(80*resize, height-200*resize, 8+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=8+16*currentpage2;
      } else {
        secondpart2=8+16*currentpage2;
      }
    }
    if (button3(160*resize, height-200*resize, 9+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=9+16*currentpage2;
      } else {
        secondpart2=9+16*currentpage2;
      }
    }
    if (button3(240*resize, height-200*resize, 10+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=10+16*currentpage2;
      } else {
        secondpart2=10+16*currentpage2;
      }
    }
    if (button3(320*resize, height-200*resize, 11+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=11+16*currentpage2;
      } else {
        secondpart2=11+16*currentpage2;
      }
    }
    if (button3(80*resize, height-120*resize, 12+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=12+16*currentpage2;
      } else {
        secondpart2=12+16*currentpage2;
      }
    }
    if (button3(160*resize, height-120*resize, 13+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=13+16*currentpage2;
      } else {
        secondpart2=13+16*currentpage2;
      }
    }
    if (button3(240*resize, height-120*resize, 14+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=14+16*currentpage2;
      } else {
        secondpart2=14+16*currentpage2;
      }
    }
    if (button3(320*resize, height-120*resize, 15+16*currentpage2, 60*resize, false, true)) {
      if (mouseButton==LEFT) {
        delay2=15+16*currentpage2;
      } else {
        secondpart2=15+16*currentpage2;
      }
    }
  }
  if (scene==2) {//selection menu(part-pixel)

    //empty  hull   armor  window
    //
    //damage primer  lens   healing
    //
    //cannon laser   pivot1  pivot2
    //
    //reflectorsX4

    if ((currentpage>0)&&button(80, 120*resize, 20, 20, "<")) {
      currentpage--;
    }
    if ((debug||currentpage<pages)&&button(320, 120*resize, 20, 20, ">")) {
      currentpage++;
    }
    if (button3(80*resize, 200*resize, 0+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=0+16*currentpage;
      } else {
        secondpart=0+16*currentpage;
      }
    }
    if (button3(160*resize, 200*resize, 1+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=1+16*currentpage;
      } else {
        secondpart=1+16*currentpage;
      }
    }
    if (button3(240*resize, 200*resize, 13+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=13+16*currentpage;
      } else {
        secondpart=13+16*currentpage;
      }
    }
    if (button3(320*resize, 200*resize, 8+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=8+16*currentpage;
      } else {
        secondpart=8+16*currentpage;
      }
    }
    if (button3(80*resize, 280*resize, 2+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=2+16*currentpage;
      } else {
        secondpart=2+16*currentpage;
      }
    }
    if (button3(160*resize, 280*resize, 5+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=5+16*currentpage;
      } else {
        secondpart=5+16*currentpage;
      }
    }
    if (button3(240*resize, 280*resize, 7+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=7+16*currentpage;
      } else {
        secondpart=7+16*currentpage;
      }
    }
    if (button3(320*resize, 280*resize, 14+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=14+16*currentpage;
      } else {
        secondpart=14+16*currentpage;
      }
    }
    if (button3(80*resize, 360*resize, 6+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=6+16*currentpage;
      } else {
        secondpart=6+16*currentpage;
      }
    }
    if (button3(160*resize, 360*resize, 15+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=15+16*currentpage;
      } else {
        secondpart=15+16*currentpage;
      }
    }
    if (button3(240*resize, 360*resize, 3+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=3+16*currentpage;
      } else {
        secondpart=3+16*currentpage;
      }
    }
    if (button3(320*resize, 360*resize, 4+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=4+16*currentpage;
      } else {
        secondpart=4+16*currentpage;
      }
    }
    if (button3(80*resize, 440*resize, 12+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=12+16*currentpage;
      } else {
        secondpart=12+16*currentpage;
      }
    }
    if (button3(160*resize, 440*resize, 9+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=9+16*currentpage;
      } else {
        secondpart=9+16*currentpage;
      }
    }
    if (button3(240*resize, 440*resize, 10+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=10+16*currentpage;
      } else {
        secondpart=10+16*currentpage;
      }
    }
    if (button3(320*resize, 440*resize, 11+16*currentpage, 60*resize, true, true)) {
      if (mouseButton==LEFT) {
        delay=11+16*currentpage;
      } else {
        secondpart=11+16*currentpage;
      }
    }
  }
  if (scene==2) {//selection menu(part-part)
    if ((currentpage2>0)&&button(80*resize, height-440*resize, 20, 20, "<")) {
      currentpage2--;
    }
    if ((debug||currentpage2<pages2)&&button(320*resize, height-440*resize, 20, 20, ">")) {
      currentpage2++;
    }
    if (button3(80*resize, height-360*resize, 0+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=0+16*currentpage2;
      } else {
        secondpart2=0+16*currentpage2;
      }
    }
    if (button3(160*resize, height-360*resize, 1+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=1+16*currentpage2;
      } else {
        secondpart2=1+16*currentpage2;
      }
    }
    if (button3(240*resize, height-360*resize, 2+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=2+16*currentpage2;
      } else {
        secondpart2=2+16*currentpage2;
      }
    }
    if (button3(320*resize, height-360*resize, 3+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=3+16*currentpage2;
      } else {
        secondpart2=3+16*currentpage2;
      }
    }
    if (button3(80*resize, height-280*resize, 4+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=4+16*currentpage2;
      } else {
        secondpart2=4+16*currentpage2;
      }
    }
    if (button3(160*resize, height-280*resize, 5+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=5+16*currentpage2;
      } else {
        secondpart2=5+16*currentpage2;
      }
    }
    if (button3(240*resize, height-280*resize, 6+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=6+16*currentpage2;
      } else {
        secondpart2=6+16*currentpage2;
      }
    }
    if (button3(320*resize, height-280*resize, 7+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=7+16*currentpage2;
      } else {
        secondpart2=7+16*currentpage2;
      }
    }
    if (button3(80*resize, height-200*resize, 8+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=8+16*currentpage2;
      } else {
        secondpart2=8+16*currentpage2;
      }
    }
    if (button3(160*resize, height-200*resize, 9+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=9+16*currentpage2;
      } else {
        secondpart2=9+16*currentpage2;
      }
    }
    if (button3(240*resize, height-200*resize, 10+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=10+16*currentpage2;
      } else {
        secondpart2=10+16*currentpage2;
      }
    }
    if (button3(320*resize, height-200*resize, 11+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=11+16*currentpage2;
      } else {
        secondpart2=11+16*currentpage2;
      }
    }
    if (button3(80*resize, height-120*resize, 12+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=12+16*currentpage2;
      } else {
        secondpart2=12+16*currentpage2;
      }
    }
    if (button3(160*resize, height-120*resize, 13+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=13+16*currentpage2;
      } else {
        secondpart2=13+16*currentpage2;
      }
    }
    if (button3(240*resize, height-120*resize, 14+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=14+16*currentpage2;
      } else {
        secondpart2=14+16*currentpage2;
      }
    }
    if (button3(320*resize, height-120*resize, 15+16*currentpage2, 60*resize, false, true)) {
      calculatecost(delay2);
      if (mouseButton==LEFT) {
        delay2=15+16*currentpage2;
      } else {
        secondpart2=15+16*currentpage2;
      }
    }
  }
  if (scene==2) {//sprite editor
    if (keyPressed&&key=='l'&&debug) {
      for (int i = 0; i<sprites2.length; i++) {
        for (int j = 0; j<sprites2[0].length; j++) {
          sprites[i][j]=sprites2[i][j];
        }
      }
    }
    if (mousePressed) {
      //System.out.println(findpartat(mouseX,mouseY,width/2,height/2,5,ship,6));
      //System.out.print(" "+findx(mouseX,width/2,5));
      if (findx(mouseX, width*0.75, 5*resize)>=0&&findx(mouseX, width*0.75, 5*resize)<8&&findx(mouseY, height/2, 5*resize)>=0&&findx(mouseY, height/2, 5*resize)<8&&!((delay<=15&&locked[delay])||(locked[1]&&delay>=16&&delay<=31)||(locked[13]&&delay>=32&&delay<=47)||(locked[1]&&delay>=32&&delay<=63)||(locked[13]&&delay>=64))&&delay2>=0) {
        if (mouseButton==LEFT) {
          sprites[delay2][findx(mouseX, width*0.75, 5*resize)+findx(mouseY, height*0.5, 5*resize)*8]=delay;
        } else if (mouseButton==RIGHT) {
          sprites[delay2][findx(mouseX, width*0.75, 5*resize)+findx(mouseY, height*0.5, 5*resize)*8]=secondpart;
        }
      }
    }
    if (keyPressed&&(key==';'||key=='\''||key=='-'||key=='=')&&delay2>=0&&delay2<cost.length) {
      cost[delay2]=0;
      for (int i = 0; i<8; i++) {
        for (int j = 0; j<8; j++) {
          cost[delay2]+=pcost[sprites[delay2][i*8+j]];
        }
      }
    }
    //outputs current sprite
    if (keyPressed&&key=='o'&&debug) {
      exportsprite(delay2);
    }

    if (delay2<sprites.length&&delay2>=0) {
      noStroke();
      fill(40);
      square(width*0.75-140*resize, height/2-140*resize, 320*resize);
      drawsprite2(width*0.75+20*resize, height/2+20*resize, 40*resize, delay2, 0, 0, doors, 100, true, true);
      drawsprite2(width*0.75+20*resize, height/2+20*resize, 40*resize, delay2, 0, 0, doors, 100, true, false);
    }
    if (keyPressed&&debug&&key==','&&delay>0) {
      delay=-1*abs(delay-1);
    }
    if (keyPressed&&debug&&key=='.'&&delay>=0) {
      delay=-1*abs(delay+1);
    }
    if ((!keyPressed)&&delay<0) {
      delay=-delay;
    }
    if (delay>=name.length&&delay<=15) {
      delay=name.length-1;
    }
    if (-delay>=name.length&&delay<=15) {
      delay=-name.length-1;
    }
    if (min(max(delay, 0), sprites.length-1)==delay) {
      fill(255, 255, 255);
      if ((delay<=15&&locked[delay])||(locked[1]&&delay>=16&&delay<=31)||(locked[13]&&delay>=32&&delay<=47)||(locked[1]&&delay>=32&&delay<=63)||(locked[13]&&delay>=64)) {//
        text("Pixel: LOCKED - Find a Research Station To Unlock", 5, 70);
      } else {
        if ((delay>=16&&delay<=31)||(delay>=48&&delay<=63)) {
          text("Pixel: "+name[1], 5, 70);
          text("Price: "+pcost[1], 5, 85);
        } else if ((delay>=32&&delay<=47)||(delay>=64)) {
          text("Pixel: "+name[13], 5, 70);
          text("Price: "+pcost[13], 5, 85);
        } else {
          text("Pixel: "+name[delay], 5, 70);
          text("Price: "+pcost[delay], 5, 85);
        }
      }
    }
    if (keyPressed&&debug&&key==';'&&delay2>0) {
      delay2=-1*abs(delay2-1);
    }
    if (keyPressed&&debug&&key=='\''&&delay2>=0) {
      delay2=-1*abs(delay2+1);
    }
    if ((!keyPressed)&&delay2<0)delay2=-delay2;
    if (delay2>=sprites.length) {
      delay2=sprites.length-1;
    }
    if (-delay2>=sprites.length) {
      delay2=(-sprites.length-1);
    }
    if (min(max(delay2, 0), sprites.length-1)==delay2) {
      fill(255, 255, 255);
      text("Part: "+delay2, 5, 30);
    }
    //drawsprite2((j-size/2)*scale+x, (i-size/2)*scale+y, scale/8, round(ship[(i*size+j)]), damagemap[i*6+j], (i*i+1)*(j+1)+i, doors);


    fill(255, 255, 255);
    if (delay2>=0&&delay2<cost.length)
      text("Price: "+cost[delay2], 5, 45);
    /**
     if (keyPressed&&key=='=') {
     shipcost=0;
     for (int i = 0; i<sizey; i++) {
     for (int j = 0; j<sizex; j++) {
     shipcost+=cost[round(ship[i*sizey+j])];
     }
     }
     //System.out.println(shipcost+" "+round(ship[1*sizey+1]));
     if (shipcost<money&&shipcost<maxcost) {
     scene=-1;
     }
     }
     **/
    //if (keyPressed&&key=='-')scene=1;
    if (button(width-165, height-40, 300, 50, "Back")) {
      calculatecost(delay2);
      scene=1;
    }
  }
  if (scene==7) {//research tree
    if (keyPressed&&escape) {
      scene2=1;
      paused=true;
      escape=false;
    }
    if (keyPressed&&key==keysindex[17]) {
      lastscene=3;
      scene2=4;
      scene=3;
    }
    /**
     research(300,300,"locked,unavailable","testing",false, false);
     research(300,700,"unlocked unavailable ","impossible",true,false);
     research(700,300,"locked available","testing",false, true);
     research(700,700,"unlocked available","testing",true,true);
     **/
    //0-empty space
    //1-white-damagable
    //2-teal-damage increaser effect
    //3-grey-pivot
    //4-grey-pivot
    //5-yellow-primer
    //6-green-not damagable(cannon)
    //7-blue-focusing effect
    //8-white-not damagable
    //9-NE corner
    //10-SW corner
    //11-NW corner
    //12-SE corner
    //13-armour
    //14-pink-healing effect
    stroke(255);
    strokeWeight(50);


    line(width*0.5, height*0.5, width*0.5, height*0.3);
    line(width*0.5, height*0.5, width*0.5, height*0.7);
    line(width*0.5, height*0.5, width*0.3, height*0.5);
    line(width*0.5, height*0.5, width*0.7, height*0.5);
    line(width*0.5, height*0.1, width*0.5, height*0.3);
    line(width*0.5, height*0.9, width*0.5, height*0.7);
    line(width*0.1, height*0.5, width*0.3, height*0.5);
    line(width*0.9, height*0.5, width*0.7, height*0.5);
    line(width*0.3, height*0.1, width*0.5, height*0.1);
    line(width*0.5, height*0.3, width*0.7, height*0.3);
    line(width*0.7, height*0.1, width*0.7, height*0.3);
    line(width*0.9, height*0.1, width*0.9, height*0.3);
    line(width*0.9, height*0.3, width*0.9, height*0.5);
    line(width*0.1, height*0.3, width*0.3, height*0.3);
    line(width*0.3, height*0.3, width*0.3, height*0.5);
    line(width*0.5, height*0.7, width*0.3, height*0.7);
    line(width*0.3, height*0.7, width*0.3, height*0.9);
    line(width*0.3, height*0.9, width*0.1, height*0.9);
    line(width*0.1, height*0.5, width*0.1, height*0.7);
    line(width*0.5, height*0.7, width*0.7, height*0.7);
    line(width*0.7, height*0.7, width*0.7, height*0.9);
    line(width*0.7, height*0.9, width*0.9, height*0.9);
    line(width*0.9, height*0.5, width*0.9, height*0.7);
    if (research(width*0.5, height*0.5, "Kinetic Core", "Fires projectiles!which can damage!enemy ships", research[0], true, 0, "Part")) {
      research[0]=true;
      locked[6]=false;
    }
    if (research(width*0.5, height*0.3, "Shops", "Shops sell parts!which can include!materials you have!not yet unlocked", research[1], research[0], 250, "Unlock")) {
      research[1]=true;
      shops=true;
    }
    if (research(width*0.5, height*0.1, "Stock", "Shops carry more!parts", research[2], research[1], 500, "Upgrade")) {
      research[2]=true;
      stock=2;
    }
    if (research(width*0.3, height*0.1, "Stock 2", "Shops carry even!more parts", research[3], research[2], 1000, "Upgrade")) {
      research[3]=true;
      stock=3;
    }
    if (research(width*0.7, height*0.3, "Discount", "Reduced prices at!shops", research[4], research[1], 500, "Upgrade")) {
      research[4]=true;
      price=0.75;
    }
    if (research(width*0.7, height*0.1, "Discount 2", "Even more reduced!prices at shops", research[5], research[4], 1000, "Upgrade")) {
      research[5]=true;
      price=0.5;
    }
    if (research(width*0.7, height*0.5, "Planets", "Ship can travel!to planets", research[6], research[0], 250, "Unlock")) {
      research[6]=true;
      planets=true;
    }
    if (research(width*0.9, height*0.5, "Ship Speed", "Ship moves!faster during combat", research[7], research[6], 500, "Upgrade")) {
      research[7]=true;
      speed=3;
    }
    if (research(width*0.9, height*0.7, "Ship Speed 2", "Ship moves!even faster!during combat", research[8], research[7], 1000, "Upgrade")) {
      research[8]=true;
      speed=4;
    }
    if (research(width*0.9, height*0.3, "Firerate", "Cannons can!fire faster", research[9], research[7], 1000, "Upgrade")) {
      research[9]=true;
      firerate=250;
    }
    if (research(width*0.9, height*0.1, "Firerate 2", "Cannons can!fire even faster", research[10], research[9], 5000, "Upgrade")) {
      research[10]=true;
      firerate=200;
    }
    if (research(width*0.3, height*0.5, "Lens", "Moves projectiles!closer to the!center of the part", research[11], research[0], 250, "Part")) {
      research[11]=true;
      locked[7]=false;
    }
    if (research(width*0.3, height*0.3, "Window", "Background part that!is invisible", research[12], research[11], 500, "Part")) {
      research[12]=true;
      locked[8]=false;
    }
    if (research(width*0.1, height*0.3, "Armor", "A pixel with a!large amount!of health", research[13], research[12], 1000, "Part")) {
      research[13]=true;
      locked[13]=false;
    }
    if (research(width*0.1, height*0.5, "Pivot", "A reflective surface!that can be turned!on and off", research[14], research[11], 500, "Part")) {
      research[14]=true;
      locked[3]=false;
      locked[4]=false;
    }
    if (research(width*0.1, height*0.7, "Healing Augment", "Reduces the damage!of projectiles", research[15], research[14], 1000, "Part")) {
      research[15]=true;
      locked[14]=false;
    }
    if (research(width*0.5, height*0.7, "Damage Augment", "Increases the!damage of projectiles", research[16], research[0], 250, "Part")) {
      research[16]=true;
      locked[2]=false;
    }
    if (research(width*0.5, height*0.9, "Damage Augment 2", "Increases the!damage of projectiles!that pass through", research[17], research[16], 500, "Part")) {
      research[17]=true;
      damageamount=1;
    }
    if (research(width*0.7, height*0.7, "Laser Emitter", "Fires beams of light! that move faster than!kinetic rounds", research[18], research[16], 500, "Upgrade")) {
      research[18]=true;
      locked[15]=false;
    }
    if (research(width*0.7, height*0.9, "Cannon Damage", "Increases the!starting damage!of fired projectiles", research[19], research[18], 1000, "Upgrade")) {
      research[19]=true;
      dmg=7;
    }
    if (research(width*0.9, height*0.9, "Cannon Damage 2", "Further Increases!starting damage!of fired projectiles", research[20], research[19], 5000, "Upgrade")) {
      research[20]=true;
      dmg=10;
    }
    if (research(width*0.3, height*0.7, "Primer", "Causes projectiles!to damage reflective!pixels", research[21], research[16], 500, "Part")) {
      research[21]=true;
      locked[5]=false;
    }
    if (research(width*0.3, height*0.9, "Part Storage", "Increases the number!of parts you can!store by 16", research[22], research[21], 1000, "Upgrade")) {
      research[22]=true;
      pages2=1;
    }
    if (research(width*0.1, height*0.9, "Part Storage 2", "Increases the number!of parts you can!store by 32", research[23], research[22], 5000, "Upgrade")) {
      research[23]=true;
      pages2=3;
    }
    /**
     0 - cannon
     1 - shops 1 - 0
     2 - stock 1 - 1
     3 - stock 2 - 2
     4 - price 1 - 1
     5 - price 2 - 4
     6 - planets 1 - 0
     7 - ship speed 1 - 6
     8 - ship speed 2 - 7
     9 - fire rate 1 - 7
     10 - fire rate 2 - 9
     11 - lens 1 - 0
     12 - ghost hull 1 - 11
     13 - armor 1 - 12
     14 - pivot 1 - 11
     15 - healing 1 - 14
     16 - damage augment 1 - 0
     17 - DI efficiency 1 - 16
     18 - dmg=2 1 - 16
     19 - dmg=3 2 - 18
     20 - dmg=5 3 - 19
     21 - primer 1 - 16
     22 - maxsize 1 - 21
     23 - maxsize 2 - 22
     **/
  }
  if (scene==8) {

    fill(255, 0, 0);
    if (debug&&keyPressed&&key=='r') {
      //planetsize++;
      noisestep*=0.9;
    }
    if (debug&&keyPressed&&key=='t') {
      //planetsize--;
      noisestep*=1.1;
    }
    //System.out.println(noisestep);
    //System.out.println(planetsize);
    /**
     if(mousePressed&&false){
     if(mouseButton==LEFT){
     planetmap[round(mouseX/nodezoom/zoom)][round(mouseY/nodezoom/zoom)]+=10;
     
     //for(int i = -2;i<3;i++){
     //  for(int j = -2;j<3;j++){
     //  planetmap[round(mouseX/nodezoom/zoom)+i][round(mouseY/nodezoom/zoom)+j]+=10/(sqrt(i*i+j*j)+1);
     //  
     //  }
     //}
     
     
     
                                                                                                                                                                /**  planetmap[round(mouseX/10/zoom)-1][round(mouseY/10/zoom)+1]+=1;
     planetmap[round(mouseX/10/zoom)-1][round(mouseY/10/zoom)]+=4;
     planetmap[round(mouseX/10/zoom)-1][round(mouseY/10/zoom)-1]+=1;
     planetmap[round(mouseX/10/zoom)][round(mouseY/10/zoom)+1]+=4;
     planetmap[round(mouseX/10/zoom)][round(mouseY/10/zoom)-1]+=4;
     planetmap[round(mouseX/10/zoom)+1][round(mouseY/10/zoom)+1]+=1;
     planetmap[round(mouseX/10/zoom)+1][round(mouseY/10/zoom)]+=4;
     planetmap[round(mouseX/10/zoom)+1][round(mouseY/10/zoom)-1]+=1;
     
     //System.out.println(planetmap[round(mouseX/10)][round(mouseY/10)]);
     }
     else{
     planetmap[round(mouseX/nodezoom/zoom)][round(mouseY/nodezoom/zoom)]-=10;
     }
     fill(0,255,0);
     circle(round(mouseX/nodezoom/zoom)*nodezoom*zoom,round(mouseY/nodezoom/zoom)*nodezoom*zoom,10);
     fill(255,0,0);
     }
     **/
    fill(0, 150, 0);

    //round(width*((250-planetsize)/500)/zoom)
    //update =
    //
    if (update) {

      for (int i = 0; i<planetsize; i++) {
        if (refresh) {
          i=refreshx;
        }
        for (int j = 0; j<planetsize; j++) {
          if (refresh) {
            j=refreshy;
            refresh=false;
          }

          //for (int i = round(width*((250-planetsize)/500)/zoom); i<width/zoom*(1-((250-planetsize)/500)); i++) {
          //  if (refresh) {
          //    i=refreshx;
          //  }
          //  for (int j = round(height*((250-planetsize)/500)/zoom); j<height/zoom*(1-((250-planetsize)/500)); j++) {
          //    if (refresh) {
          //      j=refreshy;
          //      refresh=false;
          //    }
          //if(i==refreshx&&){
          //j = refreshy;
          //}
          if (millis()-pre>targetMPF&&update) {
            refreshx=i;
            refreshy=j;
            //System.out.println(" "+i+" "+j);
            update=true;
            i=100000000;
            j=100000000;
            refresh=true;
          }



          if ( sqrt((i-(float)planetsize/2)*(i-(float)planetsize/2)+(j-(float)planetsize/2)*(j-(float)planetsize/2))>planetsize) {
            //square(i,j,1);
            // fill(0,0,255);
            //square(i*zoom,j*zoom,1);
          } else {

            tempvar2=floor(i/nodezoom);
            tempvar3=floor(j/nodezoom);
            tempvar4=(i+nodezoom)%(nodezoom*2);
            tempvar5=(j+nodezoom)%(nodezoom*2);

            //this was in this if statement and i have no idea why or what it was meant to do
            //!planetdrawmap[i][j]&&
            if ((reset||planetdrawmap[i][j])&&i+1<planetmap.length&&j+1<planetmap.length) {
              tempvar=((planetmap[tempvar2][tempvar3])/(tempvar4+tempvar5+1)+
                (planetmap[tempvar2+1][tempvar3])/(( (nodezoom*2-tempvar4)+tempvar5)+1)+//out of bounds exception:100 when planetsize is too big(>100)
                (planetmap[tempvar2][tempvar3+1])/(( tempvar4+(nodezoom*2-(tempvar5)))+1)+
                (planetmap[tempvar2+1][tempvar3+1])/(( (nodezoom*2-tempvar4)+(nodezoom*2-tempvar5))+1))-10;




              //  node1/distance node2/distance node3/distance node4/distance
              //tempvar=-100;
              //   basic circle   threshold
              //System.out.println();
              //System.out.print(planetmap[floor(i/10)][floor(j/10)]);
              //System.out.print(planetmap[ceil(i/10)][ceil(j/10)]);
              //System.out.print(floor(i/10)+" "+ceil(i/10));
              if (tempvar>=1000000000) {
                tempvar=0;
              }
              //System.out.println(tempvar);
              //i-=width/2/zoom;
              //j-=height/2/zoom;
              i-=planetsize/2;
              j-=planetsize/2;
              //fill(50,50,0,255);
              //square(i*zoom+500,j*zoom+500,zoom);
              if (((max(sqrt(i*i+j*j)*2, (float)planetsize/2-1))+tempvar*(float)planetsize/planetsmooth  < (float)planetsize*0.5   )) {
                //i+=width/2/zoom;
                //j+=height/2/zoom;
                i+=(float)planetsize/2;
                j+=(float)planetsize/2;
                planetdrawmap[i][j]=true;
                //fill(0,150,150);
                //square(i*zoom,j*zoom,zoom);
                //fill(0,150,0);
              } else {
                //i+=width/2/zoom;
                //j+=height/2/zoom;
                i+=(float)planetsize/2;
                j+=(float)planetsize/2;
                if (planetdrawmap[i][j]) {
                  money++;
                  planetdrawmap[i][j]=false;
                }
                //square(i*zoom,j*zoom,zoom);
              }
            }
          }
        }
      }
      if (reset) {
        reset=false;
      }
    }
    //System.out.println(refreshx+" "+refreshy+" "+refresh+" "+update);          //   
    //for (int i = round(width*  ((width/4-planetsize)/width/2)  /zoom); i<width/zoom*(1-((width/4-planetsize)/width/2)); i++) {
    //for (int j = round(height*  ((height/4-planetsize)/height/2)/zoom); j<height/zoom*(1-((height/4-planetsize)/height/2)); j++) {
    for (int i = 0; i<planetsize; i++) {
      for (int j = 0; j<planetsize; j++) {
        if (planetdrawmap[i][j]) {
          //System.out.println(update+" "+millis());
          //testvar=(  abs(  ((float)j-((width/zoom*(1-((250-planetsize)/500)))/1.2)))+abs(((float)i-((height/zoom*(1-((250-planetsize)/500)))/1.2))/5)  )/1300;
          testvar=(abs(j-(float)planetsize/2)-abs(i-(float)planetsize/2)/10)/700*(80/(float)planetsize);
          randomSeed(galaxy*1000000+i+j*1000);
          //System.out.println(planettexturemap[i][j]+" "+testvar);

          drawplanet(testvar, planettexturemap[i][j]);
          //if (testvar+random(0.003)>0.033) {
          //  if (planettexturemap[i][j]>0.35+testvar*5) {
          //    fill(255, 255, 255);//snow
          //  } else {
          //    fill(200, 200, 255);//ice
          //  }
          //} else if (planettexturemap[i][j]>0.7+testvar*5) {//mountaintop snow
          //  fill(225, 225, 225);
          //} else if (planettexturemap[i][j]>0.6+testvar*5) {//mountain
          //  fill(150);
          //} else if (planettexturemap[i][j]>0.4+testvar*5) {//grass
          //  fill(60, 120/planettexturemap[i][j], 60);
          //} else if (planettexturemap[i][j]>0.37+testvar*5) {//sand
          //  fill(240, 240, 100);
          //} else {
          //  fill(30, 30, (400*planettexturemap[i][j])+100);//water
          //}

          //fill(0, (planettexturemap[i][j])*200, 0);
          //fill(0,texture(i,j,100)+100,0);
          square(i*zoom+planetx-(float)planetsize, j*zoom+planety-(float)planetsize, zoom+1);
        } else {//sqrt((i-width/zoom/2)*(i-width/zoom/2)+(j-height/zoom/2)*(j-height/zoom/2))-planetsize>0
          //0 = edge
          //1+ = outside
          //1- = inside
          //

          fill(0, 150, 255, min(-10*(sqrt((i-width/zoom/2)*(i-width/zoom/2)+(j-height/zoom/2)*(j-height/zoom/2))-(float)planetsize), 100));
          //fill(255,0,0,100);
          square(i*zoom+planetx-(float)planetsize, j*zoom+planety-(float)planetsize, zoom);
        }
      }
    }
    //if(refreshx>=width/zoom*(1-((250-planetsize)/500))||refreshy>=height/zoom*(1-((250-planetsize)/500))){
    //refreshx=round(width*((250-planetsize)/500)/zoom);
    //refreshy=round(height*((250-planetsize)/500)/zoom);
    //}
    if (refreshx>=width/zoom*(1-((250-(float)planetsize)/500))) {
      refreshx=round(width*((250-(float)planetsize)/500)/zoom);
      refreshy++;
    }

    if (refreshy>=height/zoom*(1-((250-(float)planetsize)/500))) {
      refreshy=round(height*((250-(float)planetsize)/500)/zoom);
      //refreshy=round(height/zoom*(1-((250-planetsize)/500)));
      refresh=false;
      update=false;
    }
  }
  /**
   for (int i=0; i<1000; i++) {
   for (int j=0; j<1000; j++) {
   
   fill((findpart(i,j,mouseX,mouseY,5,ship,6)+1)*100,0,0,50);
   circle(i,j,2);
   }}
   **/
  //try{
  // Thread.sleep(1000);
  //}
  //catch(InterruptedException e){
  //
  //}
  if (scene==0||scene==8) {
    for (int i = 0; i<particles2.length; i++) {
      //System.out.println(particles2[i][3]+" "+particles2[i][2]);
      if (particles2[i][2]>0) {
        if (!paused) {
          particles2[i][2]/=1.1;
          particles2[i][2]-=0.1;
        }
        fill(0, 255, 0, (particles2[i][2]/particles2[i][3])*255);
        noStroke();
        circle(particles2[i][0], particles2[i][1], particles2[i][3]-particles2[i][2]);
        circle(particles2[i][0], particles2[i][1], (particles2[i][3]-particles2[i][2])*0.75);
        circle(particles2[i][0], particles2[i][1], (particles2[i][3]-particles2[i][2])*0.5);
      }
    }
  }
  if (boss==9&&scene==8) {
    for (int i=0; i<legs.length; i++) {
      leg(legs[i][0], legs[i][1], shipx2, shipy2, i);
    }
  }
  if (scene2!=0) {
    if (scene2==1) {//pause menu
      fill(100, 100, 100, 200);
      square(-5, -5, width+10);
      if (debug&&button(width/2, height*0.05, width*0.5, height*0.05, "Export Ship")) {
        System.out.println();
        System.out.print("{"+round(ship[0]));
        for (int i = 1; i<ship.length; i++) {
          System.out.print(","+round(ship[i]));
        }
        System.out.print("},");
        wait(500);
      }
      if (button(width/2, height*0.65, width*0.75, height*0.1, "Exit To Map")) {
        paused=false;
        scene2=4;
        scene=-1;
        lastscene=3;
        if (scene==0) {
          boss=0;
        }
      }
      if (button(width/2, height*0.8, width*0.75, height*0.1, "Main Menu")) {
        scene=-1;
        paused=false;
        scene2=0;
        lastscene=4;
      }
      if (button(width/2, height*0.5, width*0.75, height*0.1, "Settings")) {
        scene2=2;
      }
      if (button(width/2, height*0.35, width*0.75, height*0.1, "Controls")) {
        scene2=8;
        //scene=lastscene;
      }
      if (escape||button(width/2, height*0.2, width*0.75, height*0.1, "Resume")) {
        escape=false;
        paused=false;
        scene2=0;
        //scene=lastscene;
      }
    } else if(scene2==3){
    paused=true;
    fill(150);
    rect(width/2-150,height/2-50,300,100);
    textSize(20);
    fill(0);
    textAlign(CENTER,CENTER);
    text(message,width/2,height/2-26);
    text(message,width/2,height/2-24);
    text(message,width/2+1,height/2-25);
    text(message,width/2-1,height/2-25);
    fill(255);
    text(message,width/2,height/2-25);
    textAlign(LEFT);
    if(button(width/2,height/2+25,200,25,"Continue")){
    scene2=0;
    paused=false;
    mousePressed=false;
    }
    
    
    
    }else if (scene2==8) {

      background(150);

      keysindex[0]=controls(250, 100, 550, 60, Character.toString(keysindex[0]), keysdesc[0]);
      keysindex[2]=controls(250, 175, 550, 60, Character.toString(keysindex[2]), keysdesc[1]);
      keysindex[1]=controls(250, 250, 550, 60, Character.toString(keysindex[1]), keysdesc[2]);
      keysindex[3]=controls(250, 325, 550, 60, Character.toString(keysindex[3]), keysdesc[3]);
      keysindex[16]=controls(250, 400, 550, 60, Character.toString(keysindex[16]), keysdesc[4]);
      keysindex[17]=controls(250, 475, 550, 60, Character.toString(keysindex[17]), keysdesc[5]);
      keysindex[8]=controls(250, 550, 550, 60, Character.toString(keysindex[8]), keysdesc[6]);
      keysindex[14]=controls(250, 625, 550, 60, Character.toString(keysindex[14]), keysdesc[7]);
      keysindex[10]=controls(250, 700, 550, 60, Character.toString(keysindex[10]), keysdesc[8]);
      keysindex[12]=controls(250, 775, 550, 60, Character.toString(keysindex[12]), keysdesc[9]);
    } else if (scene2==7) {


      animationtime++;
      if (animationtime%2<1) {
        randomSeed((long)animationtime+millis()+galaxy);
        tempvar4=shipx2+random(30);
        tempvar5=shipy2+random(30);
        for (int i=0; i<10; i++) {
          if (index1>=particles.length) {
            index1=0;
          }
          particles[index1][0]=tempvar4;
          particles[index1][1]=tempvar5;
          particles[index1][2]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+xvel2;
          particles[index1][3]=(random(-particlespread, particlespread)+random(-particlespread, particlespread))*min(projectiles[i][3]/100+0.5, 2)+yvel2;
          particles[index1][4]=random(particleminsize, particlemaxsize);
          particles[index1][5]=0;
          index1++;
        }
      }
      if (animationtime>100) {
        scene2=0;
        scene=9;
      }
    } else if (scene2==2) {//settings
      fill(100, 100, 100, 200);
      square(-5, -5, width+10);
      //pressing Q + RMB in the settings menu activates debug mode
      if (keyPressed&&key=='q'&&mousePressed&&mouseButton==RIGHT) {
        debug=true;
      }
      //sliders
      particleamount=round(slider(width/2, height*0.35, width*0.75, height*0.1, 0, 10, particleamount, "Particles"));
      trailsize=10-round(slider(width/2, height*0.5, width*0.75, height*0.1, 0, 9, 10-trailsize, "Trail Length"));
      //targetMPF=round(slider(width/2, height*0.5, width*0.75, height*0.1, 10, 100, targetMPF, "Target MPF"));
      if (escape||button(width/2, height*0.2, width*0.75, height*0.1, "Back")) {
        escape=false;
        paused=true;
        scene2=1;
      }
      //unlocks everything (only shows up if debug mode is already on)
      if (debug&&button(width/2, height*0.8, width*0.75, height*0.1, "Unlock All")) {
        cheat=true;
      }
      if (button(width/2, height*0.65, width*0.75, height*0.1, "Backdrop: "+backdrop)) {
        if (backdrop) {
          backdrop=false;
        } else {
          backdrop=true;
        }
      }
    }
  }
  textSize(15);
  fill(0, 0, 0);
  text(mousetext, mouseX+1, mouseY);
  text(mousetext, mouseX, mouseY-1);
  text(mousetext, mouseX, mouseY+1);
  text(mousetext, mouseX-1, mouseY);
  fill(255, 255, 255);
  if (scene!=12&&scene!=4&&scene!=0) {
    text("Credits: "+money, zoomx(5, zoomx, zoomamount), zoomx(15, zoomy, zoomamount));
  }
  released=false;
  text(mousetext, mouseX, mouseY);
  //button(width-65,height-40,100,50,"Back");
  if (debug) {
    text("Zoom: "+zoomamount, 20, 800);
  }
  if (boss==9&&scene==8) {


    bosshealth(width/2, height*0.9, width/2, height*0.1, 0, 1000, bosshealth, "BOSS");
    if (bosshealth<=0&&scene2!=7) {
       scene2=0;
        scene=9;
      animationtime=0;
    }
  }
  //tutorial
  if (scene2==6||(scene==1&&tutorial[0])||(scene==2&&tutorial[1])||(scene==7&&tutorial[2])||(scene==0&&tutorial[3])||(scene==8&&tutorial[4])||(scene==11&&tutorial[5])) {
    // ship designer - part designer - research - combat - planet - shop
    
    
    //switch(scene){
    //case 1:
    //tutorial[0]=false;
    //break;
    //case 7:
    //tutorial[1]=false;
    //break;
    //case 0:
    //tutorial[2]=false;
    //break;
    //case 8:
    //tutorial[3]=false;
    //break;
    //case 11:
    //tutorial[4]=false;
    //break;
    //}
    
    textSize(20*resize);
switch(scene){
 
  case 0:
  textAlign(CENTER);
    text2("Defeat the enemy ship",width*0.75,height*0.25);
    text2("Press SPACE to fire",width*0.75,height*0.25+30*resize); 
    break;
    
  case 1:
  textAlign(RIGHT);
    text2("This is the ship editor.",width-100*resize,200*resize);
    text2("Click to place parts",width-100*resize,230*resize);
    
    textAlign(LEFT);
    text2("Click on a part to select it",30*resize,height/2+30*resize);
    text2("",30*resize,height/2+30*resize);
    
    //text2("This switches to the Part Design page",395,970);  
    break;

  case 2://width*0.75-140*resize, height/2-140*resize, 320*resize
  textAlign(CENTER);
    text2("This is the part editor.",width*0.75,height/2-resize*200);
    text2("Here you can make changes to your parts",width*0.75,height/2-resize*170);
    
    text2("These are your parts",200*resize,height-460*resize);
    text2("Select a part to edit",200*resize,height-440*resize);
    
    text2("These are your components",200*resize,90*resize);
    text2("Use them to edit your parts",200*resize,110*resize);    
    break;
    
  case 3:
    text2("This is the map of the solar system", 380,150);
    text2("Click the sun to go to the next solar system",350,170);
    text2("Enemy",45,45);
    text2("Research",45,85);
    text2("Planet",45,125);
    text2("Shop",45,165);
    fill(255,100,100);
    square(10,30,25);
    fill(0,0,255);
    square(10,70,25);
    fill(0,255,0);
    square(10,110,25);
    fill(255,255,0);
    square(10,150,25);
    break;
  
  case 7:
    text2("This is the research station",400,180);
    text2("Here you unlock upgrades for your ship",360,200);
    text2("Start by researching the Kinetic Core",370,220);
    break;
  
  case 8:
    text2("This is a planet", 500,150);
    text2("Harvest resources by damaging the planet",500,170);
    break;
    
  case 11:
    
    break;

} 
textAlign(LEFT);
  }

  //text(enemylvl+" "+enemydmg,500,500);
  //END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP END OF MAIN LOOP
}
public float textures(float x, float y, float size, int seed) {
  randomSeed(seed);
  x*=size;
  y*=size;
  return (sin(x)*cos(y));
}
public void calculatecost(int part) {
  if (debug) {
    return;
  }
  cost[part]=0;
  for (int i = 0; i<sprites[part].length; i++) {
    if (sprites[part][i]<=15) {
      cost[part]+=pcost[sprites[part][i]];
    } else if ((sprites[part][i]>=16&&sprites[part][i]<=31)||(sprites[part][i]>=48&&sprites[part][i]<=63)) {
      cost[part]+=pcost[1];
    } else if ((sprites[part][i]>=32&&sprites[part][i]<=47)||(sprites[part][i]>=64)) {
      cost[part]+=pcost[13];
    }
  }
}
public void resetscene() {
  for (int i=0; i<projectiles.length; i++) {
    projectiles[i][2]=0;
  }
  shipx=width/4;
  shipy=height/2;
  shipx2=width*0.75;
  shipy2=height/2;
}

public boolean research(float x, float y, String name, String hover, boolean unlocked, boolean available, int price, String type) {
  if (paused) {
    return false;
  }
  //name
  //icon
  //hover
  //x
  //y
  //unlocked
  if (unlocked&&available) {
    fill(230, 120, 30);
    stroke(180, 80, 10);
  } else if (!unlocked&&available) {
    if (money>=price) {
      fill(160);
      stroke(200);
    } else {
      fill(100);
      stroke(130);
    }
  } else if (!unlocked&&!available) {
    fill(70);
    stroke(90);
  }
  //strokeWeight(5);
  //rect(x-100,y-50,150,100);
  strokeWeight(5);
  rect(x-90, y-50, 180, 100);


  //  if (unlocked&&available) {
  //  fill(10);
  //} else if (!unlocked&&available) {
  //  if (money>=price) {
  //    fill(10);
  //  } else {
  //    fill(50);
  //  }
  //} else if (!unlocked&&!available) {
  //  fill(50);
  //}


  //fill(10);
  textSize(1);
  float size = 150/textWidth(name);
  textSize(size);
  //text(name, x-textWidth(name)/2, y+size/2-10+1);
  //text(name, x-textWidth(name)/2, y+size/2-10-1);
  //text(name, x-textWidth(name)/2+1, y+size/2-10);
  //text(name, x-textWidth(name)/2-1, y+size/2-10);
  if (unlocked&&available) {
    fill(220);
  } else if (!unlocked&&available) {
    if (money>=price) {
      fill(255);
    } else {
      fill(150);
    }
  } else if (!unlocked&&!available) {
    fill(100);
  }

  text(name, x-textWidth(name)/2, y+size/2-10);
  if (mouseX>x-100&&mouseX<x+100&&mouseY>y-50&&mouseY<y+50) {
    fill(255, 255, 255);
    String line[]=new String[5];
    int j = 0;
    line[0]="";
    for (int i = 0; i<hover.length(); i++) {
      if (hover.charAt(i)=='!') {
        j++;
        line[j]="";
      } else {
        line[j]+=hover.charAt(i);
      }
    }
    textSize(18);
    for (int i = 0; i<j+1; i++) {
      text(line[i], 15, 140+20*i);
    }
    textSize(30);
    text("Price: "+price, 15, 80);
    textSize(20);
    text(type, 15, 110);
    if (released&&available&&!unlocked&&money>=price) {
      money-=price;
      return true;
    }
  }

  return false;
}
public boolean oldresearch(float x, float y, String name, String hover, boolean unlocked, boolean available, int price, String type) {
  if (paused) {
    return false;
  }
  //name
  //icon
  //hover
  //x
  //y
  //unlocked
  if (unlocked&&available) {
    fill(200, 200, 200);
    stroke(255, 255, 255);
  } else if (unlocked&&!available) {
    fill(0, 0, 200);
    stroke(50, 50, 255);
  } else if (!unlocked&&available) {
    if (money>=price) {
      fill(0, 200, 0);
      stroke(50, 255, 50);
    } else {
      fill(200, 200, 0);
      stroke(255, 255, 50);
    }
  } else if (!unlocked&&!available) {
    fill(200, 0, 0);
    stroke(255, 50, 50);
  }
  //strokeWeight(5);
  //rect(x-100,y-50,150,100);
  strokeWeight(5);
  rect(x-90, y-50, 180, 100);
  fill(0, 0, 0);
  textSize(1);
  float size = 150/textWidth(name);
  textSize(size);
  textAlign(CENTER, CENTER);
  text(name, x, y-5);
  textAlign(LEFT, BASELINE);
  if (mouseX>x-100&&mouseX<x+100&&mouseY>y-50&&mouseY<y+50) {
    fill(255, 255, 255);
    String line[]=new String[5];
    int j = 0;
    line[0]="";
    for (int i = 0; i<hover.length(); i++) {
      if (hover.charAt(i)=='!') {
        j++;
        line[j]="";
      } else {
        line[j]+=hover.charAt(i);
      }
    }
    textSize(18);
    for (int i = 0; i<j+1; i++) {
      text(line[i], 15, 140+20*i);
    }
    textSize(30);
    text("Price: "+price, 15, 80);
    textSize(20);
    text(type, 15, 110);
    if (released&&available&&!unlocked&&money>=price) {
      money-=price;
      return true;
    }
  }

  return false;
}
public float findpixel(float x, float y, float shipx, float shipy, float scale, float ship[], int size, float damagemap[], float damagemap2[][][][], boolean sprite1) {
  x+=scale*8;
  y+=scale*8;
  x=(x-shipx)/scale/8+scale/(scale/2);
  y=(y-shipy)/scale/8+scale/(scale/2);
  float nx=round(x);
  float ny=round(y);
  if (round(ny*size+nx)>ship.length-1||round(ny*size+nx)<0||nx>=size||nx<0) {
    return -1;
  }
  if (damagemap[round(nx+ny*6)]<=0) {
    //System.out.println("test2");
    return -1;
  }
  x=round((x)*8+0.5)-nx*8+4;
  y=round((y)*8+0.5)-ny*8+4;
  x--;
  y--;
  //System.out.println(damagemap2[round(nx)][round(ny)][round(x)][round(y)]+" "+pixelhealth[round(ship[round(ny*6+nx)])]);
  //System.out.println(x+" "+y+" "+size+" "+nx+" "+ny+" "+round(ship[round(ny*size+nx)])+" "+round(y*8+x)+" "+sprites[round(ship[round(ny*size+nx)])][round(y*8+x)]);
  //System.out.println(sprites[round(ship[round(ny*size+nx)])][round(y*8+x)]);
  if (sprite1) {
    return sprites[round(ship[round(ny*size+nx)])][round(y*8+x)];
  } else {
    return sprites2[round(ship[round(ny*size+nx)])][round(y*8+x)];
  }

  //
  //sprites[  round(  ship[  round(  ny*size+nx  )  ]  )  ]  [  round(  y*8+x  )  ]
  //
}

void avoid(float x, float y) {
  //x=mouseX;
  //y=mouseY;
  if (x>shipx2-200&&y>shipy2-60&&x<shipx2-80&&y<shipy2+20) {
    keys[7]=true;
    //fill(255,0,0);
    //circle(mouseX,mouseY,30);
  } 
  if (x>shipx2-260&&y>shipy2-80&&x<shipx2-80&&y<shipy2-20) {
    keys[6]=true;
    //fill(255,255,0);
    //circle(mouseX,mouseY,20);
    
  } else if (x>shipx2-260&&y>shipy2-20&&x<shipx2-80&&y<shipy2+40) {
    keys[4]=true;
    //fill(0,255,0);
    //circle(mouseX,mouseY,10);
    
  } else if (((x>shipx2-270&&y>shipy2-100&&x<shipx2-60&&y<shipy2+60))) {
    dontmove=true;
    //fill(0,0,255);
  }
  //4 5 6 7 up left down right
            //fill(255, 0, 0, 100);
            //rect(shipx2-200, shipy2-60, 120, 80);
            //fill(255, 255, 0, 100);
            //rect(shipx2-260, shipy2-80, 190, 60);
            //fill(0, 255, 0, 100);
            //rect(shipx2-260, shipy2-20, 190, 60);
            //fill(0, 0, 255, 100);
            //rect(shipx2-270, shipy2-100, 210, 160);
}


//public void drawsprite2(float x, float y, float scale, int type, float damage, float seed, int doors, float health, boolean sprite1) {
boolean button3(float x, float y, int type, float size, boolean pixel, boolean ship) {
  if (paused) {
    return false;
  }
  if ((scene==2&&((pixel&&delay==type)||(!pixel&&delay2==type)))||(scene==1&&delay2==type)) {
    size*=1.2;
    strokeWeight(5);
    stroke(255);
    noFill();
    //square(x-size/2-2.5,y-size/2-2.5,size+5);
  } else if ((scene==2&&((pixel&&secondpart==type)||(!pixel&&secondpart2==type)))||(scene==1&&secondpart2==type)) {
    size*=1.1;
    strokeWeight(3);
    stroke(150);
    noFill();
  }

  //System.out.println(type);
  x-=size/2;
  y-=size/2;
  noStroke();
  if (pixel) {

    if (type<0||(type<=15&&locked[type])||(locked[1]&&type>=16&&type<=31)||(locked[13]&&type>=32&&type<=47)||(locked[1]&&type>=32&&type<=63)||(locked[13]&&type>=64)) {

      //lock icon
      stroke(255);
      strokeWeight(1);
      fill(100, 100, 100);
      square(x, y, size);
      noStroke();
      fill(175);
      ellipse(x+size/2, y-5+size/2, 14, size*0.4);
      fill(100, 100, 100);
      ellipse(x+size/2, y-5+size/2, 9, size*0.3);
      fill(150, 150, 150);
      rect(x+size/4, y-5+size/2, size/2, size/2, 3);
      fill(75, 75, 75);
      circle(x+size/2, y+5+size/2, size/6);
    } else {
      drawpixel2(type, 0, true, x, y, size, false);

      drawpixel2(type, 0, false, x, y, size, false);
    }
  }
  x+=size/2;
  y+=size/2;
  if (!pixel) {
    drawpixel3(x, y, type, ship, size/8);
  }
  //x+=size/2;
  //y+=size/2;

  if (mouseX<x+size/2&&mouseX>x-size/2&&mouseY>y-size/2&&mouseY<y+size/2&&(pixel||type<sprites.length)) {

    fill(0, 0, 0);
    if (pixel) {
      if (type==-1) {
        mousetext="Toggle Mode";
      } else if (type<0||(type<=15&&locked[type])||(locked[1]&&type>=16&&type<=31)||(locked[13]&&type>=32&&type<=47)||(locked[1]&&delay>=32&&delay<=63)||(locked[13]&&delay>=64)) {
        mousetext="Locked";
      } else {
        if (type<=15) {
          mousetext=name[type];
        } else if (type<=31||(type>=48&&type<=63)) {
          mousetext=name[1];
        } else {
          mousetext=name[13];
        }
      }
    }
    if (mousePressed) {
      return true;
    }
  }
  return false;
}

public void drawpixel3(float x, float y, int type, boolean ship, float scale) {
  //drawsprite2(x,y,2,type,damage,0,0,100,true);
  noStroke();
  if (type<sprites.length) {
    drawsprite2(x, y, scale, type, 0, 0, 0, 100, ship, true);
    drawsprite2(x, y, scale, type, 0, 0, 0, 100, ship, false);
  }
}

public float placepart(float x, float y, float shipx, float shipy, float scale, float ship[], int size, float part) {
  x=round((x-shipx)/scale/8+scale/(scale/2));
  y=round((y-shipy)/scale/8+scale/(scale/2));
  if (round(y*size+x)>ship.length-1||round(y*size+x)<0||x>=size||x<0) {
    return -1;
  }
  float replacedpart = ship[round(y*size+x)];
  ship[round(y*size+x)]=part;
  return replacedpart;
}

public void drawship(float x, float y, float scale, int size, float ship[], float damagemap[], int doors, float[] healthmap, boolean sprite1, boolean background) {
  scale*=8;

  for (int i=0; i<size; i++) {
    for (int j=0; j<size; j++) {
      drawsprite2((j-size/2)*scale+x, (i-size/2)*scale+y, scale/8, round(ship[(i*size+j)]), healthmap[i*6+j]-damagemap[i*6+j], (i*i+1)*(j+1)+i, doors, healthmap[i*6+j], sprite1, background);
    }
  }
  //drawoverlay(x, y, 5, size, damagemap, healthmap);
}
public void drawship2(float x, float y, float scale, int size, float ship[], float damagemap[][][][], int doors, float[] healthmap, boolean sprite1) {
  scale*=8;
  for (int i=0; i<size; i++) {
    for (int j=0; j<size; j++) {
      drawsprite3((j-size/2)*scale+x, (i-size/2)*scale+y, scale/8, round(ship[(i*size+j)]), damagemap[i][j], (i*i+1)*(j+1)+i, doors, healthmap[i*6+j], sprite1);
    }
  }
}
public void drawoverlay(float x, float y, float scale, int size, float damagemap[], float healthmap[]) {
  scale*=8;
  for (int i=0; i<size; i++) {
    for (int j=0; j<size; j++) {
      fill(0, 255, 255, ((damagemap[i*size+j]-healthmap[i*size+j])-100)/10);
      //fill(300-damagemap[(i*size+j)], 200, 200, damagemap[(i*size+j)]);
      square((j-size/2)*scale+x-20, (i-size/2)*scale+y-20, 40);
    }
  }
}
public float[] findpart2(int skip, float damagemap[]) {
  float output[]={-1, -1, 0};
  if (skip>=cannon.length) {
    return output;
  }

  if (skip<=2&&cannon[skip][2]==1) {
    //output[0]=(cannon[skip][0]*scale*8+shipx-140);
    //output[1]=(cannon[skip][1]*scale*8+shipy-140);
    //System.out.println(cannon[skip][0]+" "+cannon[skip][1]);
    if (findpartat((cannon[skip][0]*scale*8+shipx-140), (cannon[skip][1]*scale*8+shipy-140), shipx, shipy, 5, damagemap, 6)>0) {
      output[0]=(cannon[skip][0]*scale*8+shipx-140);
      output[1]=(cannon[skip][1]*scale*8+shipy-140);
      output[2]=cannon[skip][3];
    }
  }
  //System.out.println(damagemap[floor(cannon[skip][0]/8)+floor(cannon[skip][1]/8)*6]);

  return output;
}
public float findpartat(float x, float y, float shipx, float shipy, float scale, float ship3[], int size) {
  x+=scale*8;
  y+=scale*8;
  x=round((x-shipx)/scale/8+scale/(scale/2));
  y=round((y-shipy)/scale/8+scale/(scale/2));
  if (round(y*size+x)>ship3.length-1||round(y*size+x)<0||x>=size||x<0) {
    return -1;
  }
  return ship3[round(y*size+x)];
}
public float[] findpart(float x, float y, float scale, int size, float ship[], float part, int skip, float damagemap[], float part2, float part3) {
  scale*=8;
  float output[]={-1, -1};
  for (int i=0; i<size; i++) {
    for (int j=0; j<size; j++) {
      if ((ship[i*size+j]==part||ship[i*size+j]==part2||ship[i*size+j]==part3)&&damagemap[i*size+j]>0) {
        if (skip>0) {
          skip--;
        } else {
          output[0]=(j-size/2)*scale+x;
          output[1]=(i-size/2)*scale+y;
          return output;
        }
      }
      //fill(255, 0, 0, 2.55*damagemap[(i*size+j)]);
      //square((j-size/2)*scale+x-20, (i-size/2)*scale+y-20, 40);
    }
  }
  return output;
}
public float[] findpart3(int skip, float damagemap2[]) {
  float output[]={-1, -1, 0};
  if (skip>=cannon2.length) {
    return output;
  }

  if (skip<cannon2.length&&cannon2[skip][2]==1) {
    if (findpartat((cannon2[skip][0]*scale*8+shipx2-140), (cannon2[skip][1]*scale*8+shipy2-140), shipx2, shipy2, 5, damagemap2, 6)>0) {
      output[0]=(cannon2[skip][0]*scale*8+shipx2-140);
      output[1]=(cannon2[skip][1]*scale*8+shipy2-140);
      output[2]=(cannon2[skip][3]);
    }
  }

  return output;
}
public float[] finddistancetogrid(float x, float y, float scale, float shipx, float shipy) {
  x+=scale*8;
  y+=scale*8;
  x=round((x-shipx)/scale/8+scale/(scale/2));
  y=round((y-shipy)/scale/8+scale/(scale/2));
  float output[]={0, 0};
  output[0]=(x-2)*8*scale+shipx-scale*8;
  output[1]=(y-2)*8*scale+shipy-scale*8; 
  return output;
}
public void drawsprite2(float x, float y, float scale, int type, float damage, float seed, int doors, float health, boolean sprite1, boolean background) {
  float offsetx=0;
  float offsety=0;
  damage=damage/health*100;
  //System.out.println(type);
  //text(damage,x-500,y);
  //text(health,x-500,y+20);

  for (int i=0; i<8; i++) {
    for (int j=0; j<8; j++) {
      drawpixel(offsetx, offsety, i, j, seed, type, damage, scale, x, y, sprite1, background);
    }
  }
  if (type>=64&&type!=73&&(scene==1||scene==2)) {
    //fill(255,0,0,255);
    //noStroke();
    if(debug){
      noFill();
    stroke(255, 155, 0, 255);
    strokeWeight(scale/7.5);
    square(x-3.75*scale, y-3.75*scale, 7.5*scale);
    noStroke();
    }else{
    noFill();
    stroke(255, 0, 0, 255);
    strokeWeight(scale/4);
    square(x-3.75*scale, y-3.75*scale, 7.5*scale);
    line(x-3.75*scale, y-3.75*scale, x+3.75*scale, y+3.75*scale);
    line(x+3.75*scale, y-3.75*scale, x-3.75*scale, y+3.75*scale);
    noStroke();
    }
  }
}
public void drawsprite3(float x, float y, float scale, int type, float[][] damage, float seed, int doors, float health, boolean sprite1) {
  float offsetx=0;
  float offsety=0;
  for (int i=0; i<8; i++) {
    for (int j=0; j<8; j++) {
      if (sprite1) {
        damage[i][j]=damage[i][j]/pixelhealth[sprites[type][i*8+j]]*100;
      } else {
        damage[i][j]=damage[i][j]/pixelhealth[sprites2[type][i*8+j]]*100;
      }
      fill(0, 100, 0);
      //text(damage,x-500,y);
      //text(health,x-500,y+20);
      drawpixel(offsetx, offsety, i, j, seed, type, damage[i][j], scale, x, y, sprite1, false);
    }
  }
}
public void drawpixel(float offsetx, float offsety, int i, int j, float seed, int type, float damage, float scale, float x, float y, boolean sprite1, boolean background) {
  //System.out.println(second());
  damage=min(damage, 100);
  offsetx=((seed*(i+1)+j+j)%10-5)/200;
  offsety=((seed*seed*(j+1)*(i+1)+i)%10-5)/200;
  if (sprite1) {
    if (type<sprites.length) {
      tempx=sprites[type][i*8+j];
    }
  } else {
    if (type<sprites2.length) {
      tempx=sprites2[type][i*8+j];
    }
  }
  offsetx=offsetx*damage;
  offsety=offsety*damage;
  if (damage<0) {
    offsetx=0;
    offsety=0;
  }
  boolean fill = false;



  if (sprite1) {
    if (tempx==9||tempx==10||tempx==11||tempx==12) {

      switch(tempx) {
      case 9: //NE
        if ((j!=7&&sprites[type][i*8+j+1]==9)||(i!=0&&sprites[type][i*8+j-8]==9)) {
          fill=true;
        }
        break;
      case 10://SW
        if ((j!=0&&sprites[type][i*8+j-1]==10)||(i!=7&&sprites[type][i*8+j+8]==10)) {
          fill=true;
        }
        break;
      case 11://NW
        if ((j!=0&&sprites[type][i*8+j-1]==11)||(i!=0&&sprites[type][i*8+j-8]==11)) {
          fill=true;
        }
        break;
      case 12://SE
        if ((j!=7&&sprites[type][i*8+j+1]==12)||(i!=7&&sprites[type][i*8+j+8]==12)) {
          fill=true;
        }
        break;
      }
    }
  } else {
    if (tempx==9||tempx==10||tempx==11||tempx==12) {

      switch(tempx) {
      case 9: //NE
        if ((j!=7&&sprites2[type][i*8+j+1]==9)||(i!=0&&sprites2[type][i*8+j-8]==9)) {
          fill=true;
        }
        break;
      case 10://SW
        if ((j!=0&&sprites2[type][i*8+j-1]==10)||(i!=7&&sprites2[type][i*8+j+8]==10)) {
          fill=true;
        }
        break;
      case 11://NW
        if ((j!=0&&sprites2[type][i*8+j-1]==11)||(i!=0&&sprites2[type][i*8+j-8]==11)) {
          fill=true;
        }
        break;
      case 12://SE
        if ((j!=7&&sprites2[type][i*8+j+1]==12)||(i!=7&&sprites2[type][i*8+j+8]==12)) {
          fill=true;
        }
        break;
      }
    }
  }
  //System.out.println(x);
  drawpixel2(tempx, damage, background, (j-4)*scale+x+offsetx, (i-4)*scale+y+offsety, scale+1, fill);
  //System.out.println(damage);
  //damage=(float)round(damage/50)*50;
  //offsety=(float)round(offsety);
  //System.out.print("test: "+damage);


  //square((j-4)*scale+x+offsetx, (i-4)*scale+y+offsety, scale+1);
  //fill(random(-20,20),random(-20,20),random(-20,20),10);
  //square((j-4)*scale+x+offsetx, (i-4)*scale+y+offsety, scale+1);
}

public void drawpixel2(int tempx, float damage, boolean background, float x, float y, float size, boolean fill) {
  if (size>41) {
  }
  int tempshape=tempx%16;
  fill(0, 0, 0, 0);
  //System.out.println(second());
  if (background&&(tempx!=8&&tempx<=47)) {
    if (scene==2&&size>10) {
      stroke(200, 200, 200);
      strokeWeight(1);
    }


    fill(100, 100, 100, 255-damage*2);
    square(x, y, size);
  }
  noStroke();
  if ((background&&damage>=100)||((!background)&&damage<100)) {
    switch(tempx) {
    case 0://empty
      break;
    case 1://hull
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(255+damage*2, 255-damage*2, 255-damage*2, 255);
      }
      drawshape(x, y, size, 0);
      break;
    case 2://damage augment

      if (damage>=100) {
        fill(0, 50, 50, brokenalpha/2);
      } else {
        fill(0, 255-damage*1.5, 255-damage*1.5, 100);
      }
      drawshape(x, y, size, 0);


      break;
    case 3://pivot 1 NE/SW
      strokeWeight(size/5);
      if (damage>=100) {
        stroke(100, 0, 0, brokenalpha);
      } else {
        if (doors==1||doors==2) {
          stroke(200, 255-damage*2, 200-damage*2, 255);
        } else {
          stroke(75+damage, 100, 75, 255);
        }
      }
      line(x+size, y, x, y+size);
      //square(x, y, size);
      break;
    case 4://pivot 2 SE/NW
      strokeWeight(size/5);
      if (damage>=100) {
        stroke(100, 0, 0, brokenalpha);
      } else {
        if (doors==3||doors==4) {
          stroke(200, 255-damage*2, 200-damage*2, 255);
        } else {
          stroke(75+damage, 100, 75, 255);
        }
      }
      line(x, y, x+size, y+size);
      //square(x, y, size);
      break;
    case 5://primer
      if (damage>=100) {
        fill(40, 50, 0, brokenalpha/2);
      } else {
        fill(255-damage*1.5, 255-damage*1.5, 0, 100);
      }
      drawshape(x, y, size, 0);
      break;
    case 6://cannon glass
      if (damage>=100) {
        fill(0, 50, 0, brokenalpha/2);
      } else {
        fill(0, 255-damage*1.5, 0, 100);
      }
      square(x, y, size);

      triangle(x+size/2, y, x, y+size, x+size, y+size);
      break;
    case 7://lens
      if (damage>=100) {
        fill(0, 0, 50, brokenalpha/2);
      } else {
        fill(0, 0, 255-damage*1.5, 100);
      }
      drawshape(x, y, size, 0);
      break;
    case 8://window
      break;
    case 9://NE reflector
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(200, 255-damage*2, 255-damage*2, 255);
      }
      if (fill) {
        drawshape(x, y, size, 0);
      } else {
        drawshape(x, y, size, 12);
      }
      break;
    case 10://SW reflector
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(200, 255-damage*2, 255-damage*2, 255);
      }
      if (fill) {
        square(x, y, size);
      } else {
        drawshape(x, y, size, 9);
      }
      //square(x, y, size);
      break;
    case 11://NW reflector
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(200, 255-damage*2, 255-damage*2, 255);
      }
      if (fill) {
        square(x, y, size);
      } else {
        drawshape(x, y, size, 10);
      }
      //square(x, y, size);
      break;
    case 12://SE reflector
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(200, 255-damage*2, 255-damage*2, 255);
      }
      if (fill) {
        drawshape(x, y, size, 0);
      } else {
        drawshape(x, y, size, 11);
      }
      //square(x, y, size);
      break;
    case 13://armor
      if (damage>=100) {
        fill(75, 0, 0, brokenalpha);
      } else {
        fill(200, 200-damage*2, 200-damage*2, 255);
      }
      drawshape(x, y, size, 0);
      break;
    case 14://healing
      if (damage>=100) {
        fill(255, 0, 0, 100);
      } else {
        fill(255, 150-damage*1.5, 150-damage*1.5, 100);
      }
      drawshape(x, y, size, 0);
      break;
    case 15://laser
      if (damage>=100) {
        fill(50, 0, 0, brokenalpha/2);
      } else {
        fill(255-damage*1.5, 0, 0, 100);
      }
      drawshape(x, y, size, 0);
      fill(255, 50, 50);
      triangle(x+size/2, y, x, y+size, x+size, y+size);
      break;
    }
    //cosmetic hull

    switch(tempshape%16) {
    case 2://4
      tempshape=6;//2
      break;
    case 8://10
      tempshape=3;//3
      break;
    case 4://8
      tempshape=15;//4
      break;
    case 5://6
      tempshape=7;//5
      break;
    case 6://11
      tempshape=8;//6
      break;
    case 7://5
      tempshape=4;//7
      break;
    case 1://3
      tempshape=12;//8
      break;
    case 13://2
      tempshape=2;//9
      break;
    case 14://7
      tempshape=5;//10
      break;
    case 3:
      tempshape=14;
      break;
    case 15:
      tempshape=13;
      break;
    case 12:
      tempshape=11;
      break;
    case 9:
      tempshape=12;
      break;
    case 10:
      tempshape=9;
      break;
    case 11:
      tempshape=10;
      break;
    }
    if (size>41) {
    }

    if ((tempx>=16&&tempx<=31)||(tempx>=48&&tempx<=63)) {
      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(255+damage*2, 255-damage*2, 255-damage*2, 255);
      }
      drawshape(x, y, size, tempshape);
    } else if ((tempx>=32&&tempx<=47)||(tempx>=64&&tempx<=79)) {
      if (damage>=100) {
        fill(75, 0, 0, brokenalpha);
      } else {
        fill(200, 200-damage*2, 200-damage*2, 255);
      }
      drawshape(x, y, size, tempshape);
    } else if (tempx>=80&&tempx<=95) {

      if (damage>=100) {
        fill(100, 0, 0, brokenalpha);
      } else {
        fill(255+damage*2, 255-damage*2, 255-damage*2, 255);
      }
      drawshape(x, y, size, 0);
      if (damage>=100) {
        fill(75, 0, 0, brokenalpha);
      } else {
        fill(200, 200-damage*2, 200-damage*2, 255);
      }
      drawshape(x, y, size, tempshape);
    }
  }
}

void drawshape(float x, float y, float size, int type) {
  //System.out.println(size+" "+x+" "+y);
  switch(type) {
  case 0://full square
    square(x, y, size);
    break;
  case 1://NS 
    triangle(x+size/2, y+size/2, x, y+size, x+size, y+size);
    triangle(x, y, x+size, y, x+size/2, y+size/2);
    break;
  case 2://WE
    triangle(x, y, x, y+size, x+size/2, y+size/2);
    triangle(x+size/2, y+size/2, x+size, y, x+size, y+size);
    break;
  case 3://Circle
    circle(x+size/2, y+size/2, size);
    break;
  case 4://N
    triangle(x+size/2, y+size/2, x, y+size, x+size, y+size);
    break;
  case 5://E
    triangle(x, y, x, y+size, x+size/2, y+size/2);
    break;
  case 6://S
    triangle(x, y, x+size, y, x+size/2, y+size/2);
    break;
  case 7://W
    triangle(x+size/2, y+size/2, x+size, y, x+size, y+size);
    break;
  case 12://NE
    triangle(x, y, x, y+size, x+size, y+size);
    break;
  case 9://SW
    triangle(x, y, x+size, y, x+size, y+size);
    break;
  case 10://NW
    triangle(x+size, y, x, y+size, x+size, y+size);
    break;
  case 11://SE
    triangle(x, y, x, y+size, x+size, y);
    break;

    /**
     case 12://NE
     triangle(x-1, y-1, x, y+size, x+size+1, y+size+1);
     break;
     case 9://SW
     triangle(x-1, y-1, x+size, y, x+size+1, y+size+1);
     break;
     case 10://NW
     triangle(x+size+1, y-1, x-1, y+size+1, x+size, y+size);
     break;
     case 11://SE
     triangle(x-1, y-1, x-1, y+size+1, x+size+1, y-1);
     break;**/
  case 8://N
    triangle(x+size, y, x, y+size, x+size, y+size);
    triangle(x, y, x, y+size, x+size, y+size);
    break;
  case 13://E
    triangle(x, y, x, y+size, x+size, y+size);
    triangle(x, y, x, y+size, x+size, y);
    break;
  case 14://S
    triangle(x, y, x, y+size, x+size, y);
    triangle(x, y, x+size, y, x+size, y+size);
    break;
  case 15://W
    triangle(x+size, y, x, y+size, x+size, y+size);
    triangle(x, y, x+size, y, x+size, y+size);
    break;
  }
}

public void wait(int time) {
  try {
    Thread.sleep(time);
  }
  catch(InterruptedException e) {
  }
}

void keyPressed() {

  if (key == ESC) {
    key = 0;
    if (scene2!=1&&scene2!=2&&scene!=4) {
      lastscene=scene;
    }
    escape=true;
  }
  //if((shipx>width/2-100||shipx<140||shipx2<width/2+140||shipx2>width-100||shipy<140||shipy>height-100||shipy2<140||shipy2>height-100)){}else{
  for (int i=0; i<keys.length; i++) {
    if (keysindex[i]==key||Character.toUpperCase(keysindex[i])==key) {
      if (keys2[i]==true) {
        keys[i]=true;
      }
      switch(i) {
      case 0:
        keys2[2]=true;
        break;
      case 1:
        keys2[3]=true;
        break;
      case 2:
        keys2[0]=true;
        break;
      case 3:
        keys2[1]=true;
        break;
      case 4:
        keys2[6]=true;
        break;
      case 5:
        keys2[7]=true;
        break;
      case 6:
        keys2[4]=true;
        break;
      case 7:
        keys2[5]=true;
        break;
      }
      break;
    }
  }
}
void keyReleased() {
  if (key == ESC) {
    key = 0;
    escape=false;
  }
  for (int i=0; i<keys.length; i++) {
    if (keysindex[i]==key||Character.toUpperCase(keysindex[i])==key) {
      keys[i]=false;
      break;
    }
  }
}
void mouseReleased() {
  released=true;
}
boolean buttonold(float x, float y, float x2, float y2, String text) {
  strokeWeight(5);

  if ((mousePressed||released)&&mouseX>=(x-(x2/2))&&mouseX<=x+(x2/2)&&mouseY>=(y-(y2/2))&&mouseY<=y+(y2/2)) {
    if (released) {
      released=false;
      return true;
    }
    textSize(y2*0.89);
    stroke(170, 170, 170);
    fill(150, 150, 150);
    rect(x-x2/2+1, y-y2/2+1, x2-2, y2-2);
    fill(130, 130, 130);
    text(text, x-textWidth(text)/2, y+y2*0.35);
    return false;
  } else {
    textSize(y2*0.9);
    stroke(145, 145, 145);
    fill(125, 125, 125);
    rect(x-x2/2, y-y2/2, x2, y2);
    fill(105, 105, 105);
    text(text, x-textWidth(text)/2, y+y2*0.33);
  }
  return false;
}
/**boolean error(float x, float y, float x2, float y2, String text) {
 strokeWeight(5);
 
 
 if ((mousePressed||released)&&mouseX>=(x-(x2/2))&&mouseX<=x+(x2/2)&&mouseY>=(y-(y2/2))&&mouseY<=y+(y2/2)) {
 if (released) {
 return true;
 }
 textSize(y2*0.89);
 stroke(170, 170, 170);
 fill(150, 150, 150);
 rect(x-x2/2+1, y-y2/2+1, x2-2, y2-2);
 fill(130, 130, 130);
 text(text, x-textWidth(text)/2, y+y2*0.35);
 return false;
 } else {
 textSize(y2*0.9);
 stroke(145, 145, 145);
 fill(125, 125, 125);
 rect(x-x2/2, y-y2/2, x2, y2);
 fill(105, 105, 105);
 text(text, x-textWidth(text)/2, y+y2*0.33);
 }
 return false;
 }**/
//float offsetx, float offsety, int i, int j, float seed, int type, float damage, float scale, float x, float y, boolean sprite1) {

boolean button2(float x, float y, float size, String text) {
  push();
  if (!paused&&sqrt((mouseX-x)*(mouseX-x)+(mouseY-y)*(mouseY-y))<max(size, 20)) {//mouseover

    strokeWeight(3);
    stroke(255, 255, 255);
    circle(x, y, size);
    strokeWeight(1);
    fill(255, 255, 255, 100);
    circle(x, y, max(size, 40));
    if (released) {
      pop();
      return true;
    }
    mousetext=text;
    pop();
    return false;
  } else {
    strokeWeight(1);
    circle(x, y, size);
  }
  pop();
  return false;
}
public void drawsprite(float x, float y, float size, float rgb[][][]) {
  for (int i = 0; i<rgb.length; i++) {
    for (int j = 0; j<rgb[0].length; j++) {
      fill(rgb[i][j][0], rgb[i][j][1], rgb[i][j][2]);
      square(i+x-(rgb.length/2*size), j+y-(rgb[0].length/2*size), size);
    }
  }
}
public int findx(float x, float shipx, float scale) {
  x+=scale*8;
  x=(x-shipx)/scale/8+scale/(scale/2);
  return round(x);
}
public float findy(float x, float shipx, float scale) {
  x+=scale*26;
  x=(x-shipx)/scale+scale/(scale/2);
  return (x);
}
int sliderold(float x, float y, float x2, float y2, int p1, int p2, int num, String text) {
  strokeWeight(5);
  stroke(170, 170, 170);
  textSize(y2*0.9);
  //System.out.println(num+" "+p1+" "+p2);
  fill(125, 125, 125);
  if (mousePressed&&mouseX>(x-x2/2)&&mouseX<(x+x2/2)+x2/(p2-p1)&&mouseY>y-y2/2&&mouseY<y+y2/2) {
    fill(145, 145, 145);
    //System.out.println((mouseX-x+x2/2)/(x2/(p2-p1)));
    rect(x-x2/2, y-y2/2, x2+(x2/(p2-p1)), y2);
    fill(130, 130, 130);
    text(text, x-textWidth(text)/2, y+y2*0.35);
    fill(170, 170, 170);
    noStroke();
    rect((x-x2/2)+(num-p1/(p2-p1))*x2/(p2-p1), y-y2/2, x2/abs(p2-p1), y2, 100);
    return round((mouseX-x+x2/2)/(x2/(p2-p1)));
  }           //((mouseX-x)*(p2-p1)/x2  -p1/(p2-p1))*x2/(p2-p1)
  rect(x-x2/2, y-y2/2, x2+(x2/(p2-p1)), y2);
  fill(105, 105, 105);
  text(text, x-textWidth(text)/2, y+y2*0.3);
  fill(145, 145, 145);
  noStroke();
  rect((x-x2/2)+(num-p1/(p2-p1))*x2/(p2-p1), y-y2/2, x2/abs(p2-p1), y2, 100);
  return num;
}
void drawbackground() {
  starnum=0;
  GALseed1+=random(2, 10);
  GALseed2-=random(2, 10);
  for (int i = 0; i<width/GALscale; i++) {
    for (int j = 0; j<height/GALscale; j++) {
      noiseSeed((long)GALseed1);
      GALtempvar1=noise(i/GALnoisescale, j/GALnoisescale);
      noiseSeed((long)GALseed2);
      GALtempvar2=noise(i/GALnoisescale2, j/GALnoisescale2);
      GALtempvar3=GALtempvar1*GALtempvar2*GALtempvar1*GALtempvar2;
      if (i<background.length&&j<background[0].length) {
        background[i][j][0]=GALtempvar1*50;
        background[i][j][1]=GALtempvar2*50;
      }
      for (int k=0; k<GALstaramount; k++) {
        if (0<(GALtempvar1*GALtempvar2-random(1))&&starnum<stars.length) {
          stars[starnum][0]=ceil(GALscale*i+random(GALscale));
          stars[starnum][1]=ceil(GALscale*j+random(GALscale));
          stars[starnum][2]=ceil(random(100));
          starnum++;//GALscale*i+random(GALscale), GALscale*j+random(GALscale),
        }
      }
    }
  }
}
float bosshealth(float x, float y, float x2, float y2, float p1, float p2, float num, String text) {


  if (num<0) {
    num=0;
  }

  textSize(y2*0.5);
  strokeWeight(1);
  stroke(0, 0, 0);
  fill(120);
  rect(x-x2/2-5, y-5, x2+10, y2/2+10);
  fill(160);
  rect(x-x2/2, y, x2, y2/2);
  fill(255, 0, 0);
  rect(x-x2/2, y, x2*(num/(p2-p1)), y2/2);
  return num;
}
float slider(float x, float y, float x2, float y2, float p1, float p2, float num, String text) {



  strokeWeight(3);
  stroke(170, 170, 170);
  textSize(y2*0.5);
  //System.out.println(num+" "+p1+" "+p2);
  fill(125, 125, 125);
  if (mousePressed&&mouseX>(x-x2/2)&&mouseX<(x+x2/2)+x2/(p2-p1)&&mouseY>y&&mouseY<y+y2/2) {
    strokeWeight(1);
    stroke(0, 0, 0);
    fill(130);
    rect(x-x2/2-5, y-y2/2-5, x2+10, y2+10);
    noStroke();

    textAlign(CENTER);
    fill(0, 0, 0);
    text(text, x+1, y-y2*0.1);
    text(text, x-1, y-y2*0.1);
    text(text, x, y-y2*0.1+1);
    text(text, x, y-y2*0.1-1);
    fill(255, 255, 255);
    text(text, x, y-y2*0.1);
    textAlign(LEFT);
    fill(180);
    stroke(0, 0, 0);
    strokeWeight(1);
    rect(x-x2/2, y, x2, y2/2);
    fill(255, 150, 60);
    rect(x-x2/2, y, x2*(num/(p2-p1)), y2/2);
    textAlign(CENTER, TOP);
    fill(0);
    text(round(num), x, y-y2*0.05);
    textAlign(LEFT);
    return min(max(round((mouseX-x+x2/2)/(x2/(p2-p1))), p1), p2);
  }           //((mouseX-x)*(p2-p1)/x2  -p1/(p2-p1))*x2/(p2-p1)
  strokeWeight(1);
  stroke(0, 0, 0);
  fill(120);
  rect(x-x2/2-5, y-y2/2-5, x2+10, y2+10);
  noStroke();
  fill(255, 255, 255);
  textAlign(CENTER);
  fill(0, 0, 0);
  text(text, x+1, y-y2*0.1);
  text(text, x-1, y-y2*0.1);
  text(text, x, y-y2*0.1+1);
  text(text, x, y-y2*0.1-1);
  fill(255, 255, 255);
  text(text, x, y-y2*0.1);
  textAlign(LEFT);
  fill(160);
  stroke(0, 0, 0);
  strokeWeight(1);
  rect(x-x2/2, y, x2, y2/2);
  fill(255, 150, 60);
  rect(x-x2/2, y, x2*(num/(p2-p1)), y2/2);
  textAlign(CENTER, TOP);
  fill(0);
  text(round(num), x, y-y2*0.05);
  textAlign(LEFT);
  //fill(255, 150, 60);
  //rect(x-x2/2, y+0*height,(num-p1/(p2-p1))*x2/(p2-p1), y2*.45);
  //fill(255, 150, 60);
  //rect(x-x2/2, y,x2, y2/2);
  //rect(x-x2/2, y,x2+(x2/(p2-p1)), 3);
  //rect(x-x2/2,y-y2/2,x2,y2);
  //(x-x2/2)+(num-p1/(p2-p1))*x2/(p2-p1)
  //(x-x2)+(num-p1/(p2-p1))*x2/(p2-p1)
  return num;
}
boolean button(float x, float y, float x2, float y2, String text) {
  noStroke();
  strokeWeight(1);
  x-=x2/2;
  y-=y2/2;

  if (mouseX>=(x)&&mouseX<=x+(x2)&&mouseY>=(y)&&mouseY<=y+(y2)) {

    stroke(255);
    //noStroke();  
    textSize(y2*0.85);
    fill(0, 0, 0);
    rect(x, y, x2, y2);
    //fill(85,85,85);
    fill(160);
    rect(x, y, x2, y2);
    fill(255);
    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8+1);
    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8-1);
    text(text, x+x2/2-(textWidth(text)/2)+1, y+y2*0.8);
    text(text, x+x2/2-(textWidth(text)/2)-1, y+y2*0.8);
    fill(255, 255, 255);
    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8); 
    if (released) {
      released=false;
      return true;
    }
    return false;
  } else {
    stroke(0, 0, 0);
    //noStroke();  
    textSize(y2*0.85);
    fill(0, 0, 0);
    rect(x, y, x2, y2);
    fill(120);
    rect(x, y, x2, y2);
    fill(0, 0, 0);

    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8+1);
    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8-1);
    text(text, x+x2/2-(textWidth(text)/2)+1, y+y2*0.8);
    text(text, x+x2/2-(textWidth(text)/2)-1, y+y2*0.8);
    fill(255, 255, 255);
    text(text, x+x2/2-(textWidth(text)/2), y+y2*0.8);
  }

  return false;
}
void widetext(String text, float x, float y, float size) {
  while (size>0) {
    //edges
    text(text, x-textWidth(text)/2, y+size);
    text(text, x-textWidth(text)/2+size, y);
    text(text, x-textWidth(text)/2, y-size);
    text(text, x-textWidth(text)/2-size, y);
    //corners
    text(text, x-textWidth(text)/2+size, y+size);
    text(text, x-textWidth(text)/2+size, y-size);
    text(text, x-textWidth(text)/2+size, y-size);
    text(text, x-textWidth(text)/2-size, y-size);
    size--;
  }
}
boolean button4(float x, float y, float ship[], float cost) {
  if (paused) {
    return false;
  }
  noStroke();
  drawship(x, y, 5, 6, ship, damagemap, 0, healthmap, true, true);
  drawship(x, y, 5, 6, ship, damagemap, 0, healthmap, true, false);
  if (mouseX>x-140&&mouseX<x+100&&mouseY>y-140&&mouseY<y+100) {
    mousetext="Cost: "+(cost-shipcost);
    noFill();
    stroke(255, 255, 255);
    strokeWeight(3);
    square(x-140, y-140, 240);
    if (mousePressed&&money+shipcost>=cost) {
      return true;
    }
  }
  return false;
}

char controls(float x, float y, float x2, float y2, String text, String text2) {

  text=Character.toString(Character.toUpperCase(text.charAt(0)));
  String displaytext=text;
  if (displaytext.equals(" ")) {
    displaytext="SPACE";
  }
  if (mouseX>x&&mouseY>y&&mouseX<x+x2&&mouseY<y+y2) {
    stroke(0, 0, 0);
    textAlign(CENTER);
    textSize(y2*.7);
    fill(0, 0, 0);
    rect(x, y, x2, y2);
    fill(160);
    rect(x, y, x2, y2);
    fill(0, 0, 0);
    text(displaytext, x+(x2/7.5), y+y2*.8+1);//text
    text(displaytext, x+(x2/7.5), y+y2*.8-1);
    text(displaytext, x+(x2/7.5)+1, y+y2*.8);
    text(displaytext, x+(x2/7.5)-1, y+y2*.8);
    fill(255, 255, 255);
    text(displaytext, x+(x2/7.5), y+y2*.8);
    fill(0, 0, 0);
    text(text2, x+x2/2+(x2/5), y+y2*.8+1);//text2
    text(text2, x+x2/2+(x2/5), y+y2*.8-1);
    text(text2, x+x2/2+(x2/5)+1, y+y2*.8);
    text(text2, x+x2/2+(x2/5)-1, y+y2*.8);
    fill(255, 255, 255);
    text(text2, x+x2/2+(x2/5), y+y2*.8);
    textAlign(LEFT);
    if (keyPressed) {
      return key;
    } else {
      return Character.toLowerCase(text.charAt(0));
    }
  }
  stroke(0, 0, 0);
  textAlign(CENTER);
  textSize(y2*.7);
  fill(0, 0, 0);
  rect(x, y, x2, y2);
  fill(120);
  rect(x, y, x2, y2);
  fill(0, 0, 0);
  text(displaytext, x+(x2/7.5), y+y2*.8+1);//text
  text(displaytext, x+(x2/7.5), y+y2*.8-1);
  text(displaytext, x+(x2/7.5)+1, y+y2*.8);
  text(displaytext, x+(x2/7.5)-1, y+y2*.8);
  fill(255, 255, 255);
  text(displaytext, x+(x2/7.5), y+y2*.8);
  fill(0, 0, 0);
  text(text2, x+x2/2+(x2/5), y+y2*.8+1);//text2
  text(text2, x+x2/2+(x2/5), y+y2*.8-1);
  text(text2, x+x2/2+(x2/5)+1, y+y2*.8);
  text(text2, x+x2/2+(x2/5)-1, y+y2*.8);
  fill(255, 255, 255);
  text(text2, x+x2/2+(x2/5), y+y2*.8);
  textAlign(LEFT);
  return Character.toLowerCase(text.charAt(0));
}
void circle2(float[] projectile) {
  if (projectile[3]>0) {//if damage > 0
    if (projectile[2]==5) {
      //fill(255, 0, 0);//red
    } else {

      //fill(255, 51*projectile[4], 0);//yellow
    }
  } else { // if damage <0
    fill(0, 255, 0);//green
  }
  breakloop=false;
  for (int i = index3; i<index3||!breakloop; i++) {
    if (i>=particles3.length) {
      i-=particles3.length;
      breakloop=true;
    }
    if (particles3[i][2]<=0&&!paused) {
      particles3[i][0]=projectile[0];
      particles3[i][1]=projectile[1];
      particles3[i][2]=min(abs(projectile[3]), 200);
      particles3[i][3]=min(abs(projectile[3]), 200);
      if (projectile[4]>0&&projectile[3]>0) {
        particles3[i][4]=1;
      } else if (projectile[3]<0) {
        particles3[i][4]=2;
      } else {
        particles3[i][4]=0;
      }
      index3=i;
      break;
    }
  }
  //if (projectile[3]>200) {
  //  circle(projectile[0], projectile[1], 28.28);
  //} else {
  //  circle(projectile[0], projectile[1], sqrt(projectile[3])*2);
  //}
  //text(projectile[3], projectile[0], projectile[1]);
}

void exportsprite(int delay2) {
  System.out.println();
  System.out.print(", {");
  for (int i = 0; i<7; i++) {
    for (int j = 0; j<8; j++) {
      System.out.print(sprites[delay2][i*8+j]+", ");
    }
  }
  for (int j = 0; j<7; j++) {
    System.out.print(sprites[delay2][56+j]+", ");
  }
  System.out.print(sprites[delay2][63]+"}");
  wait(500);
}
float zoomx(float x1, float x2, float amount) {
  if (amount==1) {
    return x1;
  }
  return (x1-x2)*amount+x2;
}






void setplanet() {
  for(int i=0;i<particles4.length;i++){
  particles4[i][4]=0;
  }
  reset=true;
  randomSeed(objectnumb+galaxy);
  planetx=random(width*0.6, height*0.9);
  planety=random(height*0.25, height*0.75);
  planettype=ceil(random(5));
  //planettype=5;

  //for (int i=0; i<drones.length; i++) {
  //  drones[i][0]=planetx;
  //  drones[i][1]=planety;
  //  drones[i][3]=planetx;
  //  drones[i][4]=planety;
  //}

  switch(planettype) {

  case 1://earth
    planetsize=ceil(random(80, 100));
    planetsmooth=120;
    break;

  case 2://test
    planetsize=ceil(random(60, 80));
    planetsmooth=110;
    break;

  case 3://mars
    planetsize=ceil(random(80, 100));
    planetsmooth=120;
    break;

  case 4://purple
    planetsize=ceil(random(80, 100));
    planetsmooth=120;
    break;  
  case 5://desert
    planetsize=ceil(random(80, 100));
    planetsmooth=120;
    break;
  }
        for (int i = 0; i<planetmap.length; i++) {
          for (int j = 0; j<planetmap[0].length; j++) {        
            planetmap[i][j]=random(-10, 10);
          }
        }
        
        for (int i = 0; i<planettexturemap.length; i++) {
          for (int j = 0; j<planettexturemap[0].length; j++) {
            planettexturemap[i][j]=noise((((float)i)*noisestep), ((float)j)*noisestep);
          }
        }
}

void drawplanet(float poles, float depth) {
  //poles/=7;
  //the poles variable increases the closer you are to the top or bottom of the planet(0.3 is the current height of the snow and ice)
  //depth determines how high the pixel is and what type it should be
  depth-=poles*5;//lowers height near the poles(-0.5 at the poles and -0.3 at the edge of the snow)

  switch(planettype) {
  case 0:
  fill(0,0,255);
    break;

  case 1:
    if (poles+random(0.003)>0.033) {//if in the snowy area
      if (depth>0.35+testvar*5) {//snow
        fill(255, 255, 255);
      } else {//ice
        fill(200, 200, 255);
      }
    } else if (depth>0.7) {//mountaintop snow
      fill(225, 225, 225);
    } else if (depth>0.6) {//mountain
      fill(150);
    } else if (depth>0.4) {//grass
      fill(60, 120/depth, 60);
    } else if (depth>0.37) {//sand
      fill(240, 240, 100);
    } else {
      fill(30, 30, (400*depth)+100);//water
    }
    break;
  case 2:

    if (depth<0.5) {
      fill(255-depth*100, 255-depth*60, 255-depth*60);
    } else {
      fill(220-depth*100, 220-depth*60, 255-depth*60);
    }
    //if (poles+random(0.003)>0.033) {//if in the snowy area
    //  if (depth>0.35+testvar*5) {//snow
    //    fill(255, 255, 255);
    //  } else {//ice
    //    fill(200, 200, 255);
    //  }
    //} else if (depth>0.7) {//mountaintop snow
    //  fill(225, 225, 225);
    //} else if (depth>0.6) {//mountain
    //  fill(150);
    //} else if (depth>0.4) {//grass
    //  fill(60, 120/depth, 60);
    //} else if (depth>0.37) {//sand
    //  fill(240, 240, 100);
    //} else {
    //  fill(30, 30, (400*depth)+100);//water
    //}
    break;
  case 3:

    if (poles+random(0.003)>0.031) {//if in the snowy area
      if (depth>0.35+testvar*5) {//snow
        fill(255, 255, 255);
      } else {
        fill(255);
      }
    } else if (depth>0.65) {//brown
      fill(120, 60, 50);
    } else if (depth>0.4) {//darker red
      fill(180-depth*50, 60, 50);
    } else {
      fill(161+depth*50, 61, 45);//lighter red
    }
    break;
  case 4:

    if (depth>0.6) {
      fill(128, 0, 128);
    } else if (depth>0.4) {
      fill(200, 50, 200);
    } else if (depth>0.2) {
      fill(160, 0, 211);
    } else {
      fill(210+depth*50, 100, 210+depth*50);
    }
    break;
  case 5:

    if (depth<0.50) {
      fill(255-depth*30, 200-depth*30, 20);//light
    } else {
      //fill(220+depth*100,170+depth*60,20);//dark
      fill(205+depth*100, 170+depth*60, 20);//dark
    }
    break;
  }
}
void text2(String text,float x,float y){
fill(0);
text(text,x+1,y);
text(text,x-1,y);
text(text,x,y+1);
text(text,x,y-1);
fill(255);
text(text,x,y);
}
void leg(float x, float y, float x2, float y2, int i) {
  switch(i) {
  case 0:
    x2+=30;
    break;
  case 1:
    x2-=30;
    break;
  case 2:
    y2+=30;
    break;
  case 3:
    y2-=30;
    break;
  case 4:
    x2+=21.2132034356;
    y2+=21.2132034356;
    break;
  case 5:
    x2-=21.2132034356;
    y2+=21.2132034356;
    break;
  case 6:
    x2-=21.2132034356;
    y2-=21.2132034356;
    break;
  case 7:
    x2+=21.2132034356;
    y2-=21.2132034356;
    break;
  }
  float dis=(max(200-sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2)), 0))/2;
  float halfx=x-(x-x2)/2;
  float halfy=y-(y-y2)/2;

  //fill(0,255,255);
  //circle(halfx,halfy,10);
  strokeWeight(3);
  stroke(100, 100, 100);
  line(x, y, halfx, halfy-dis);
  line(x2, y2, halfx, halfy-dis);
  noStroke();
}




void border(float x,float y,float x2,float y2,int num,float speed){
  //System.out.println(x2+" "+y2);
  randomSeed(millis());
for(int i=0;i<num;i++){
  for(int j=0;j<particles4.length;j++){
    particleindex4++;
    if(particleindex4>=particles4.length){
    particleindex4=0;
    }
    
    
  if(particles4[particleindex4][4]<=0){
  particles4[particleindex4][0]=random(x,x);
  particles4[particleindex4][1]=random(y,y+y2);
  particles4[particleindex4][2]=random(-y2,y2)/1000*particlerepetition*speed;
  //particles4[particleindex4][3]=random(-x2,x2)/1000*particlerepetition*speed;
  particles4[particleindex4][4]=random(3,6);
  break;
  }
  
  }
  
  
  
}
  
  

}
